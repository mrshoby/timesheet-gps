<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SERVELECT • Admin Pontaj</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="icon" href="favicon.png" />
  <meta name="theme-color" content="#516A75"/>
  <style>
    :root{
      --brand:#516B74;
      --brand-weak:rgba(81,106,117,0.88);
      --accent:#95CA4B;
      --text:#0f172a;
      --muted:#5b6b73;
      --bg:#f4f7f9;
      --card:#ffffff;
      --ring:#cfe0e7;
      --danger:#ef4444;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    html,body{height:100%; width:100%}
    body{
      margin:0;
      font-family: Montserrat, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        linear-gradient(180deg, rgba(149, 202, 75, 0.91) 0%, rgba(81, 106, 117, 0.88) 66%),
        url('background.jpg');
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      min-height:100vh;
    }
    .shell{max-width:1200px;margin:0 auto;padding:24px;}
    .nav{
      display:flex;align-items:center;justify-content:space-between;
      gap:16px;padding:14px 16px;border-radius:16px;
      background:linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.80));
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 30px rgba(81,106,117,.18);
      border:1px solid rgba(81,106,117,.18);
    }
    .brand{display:flex;align-items:center;gap:12px;text-decoration:none;color:inherit}
    .brand img{ width:38px;height:38px;object-fit:contain;aspect-ratio:1/1;border-radius:10px;box-shadow:0 3px 10px rgba(81,106,117,.25) }
    .brand h1{font-size:18px;letter-spacing:.2px;margin:0;line-height:1.1}
    .brand h1 span{display:block;font-weight:700}
    .brand small{display:block;font-size:12px;color:var(--muted);margin-top:2px}

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(81,106,117,.10);
      color:#2f3e45;
      font-weight:600;
      font-size:12px;
    }

    .card{
      background:var(--card);
      border:1px solid rgba(14,165,233,.12);
      border-radius:18px;
      box-shadow: 0 20px 60px rgba(2,132,199,.08);
    }

    .admin-layout{
      margin-top:20px;
      display:grid;
      grid-template-columns: minmax(0,2.5fr) minmax(260px,1fr);
      gap:18px;
      align-items:flex-start;
    }
    @media (max-width:960px){
      .admin-layout{ grid-template-columns:1fr; }
    }

    .admin-main{
      padding:18px 18px 16px;
      border-radius:18px;
      background:rgba(248,250,252,.92);
      backdrop-filter: blur(6px);
      border:1px solid rgba(148,163,184,.25);
    }

    .admin-header{
      display:flex;
      flex-wrap:wrap;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom:14px;
    }
    .admin-header h1{
      margin:0;
      font-size:20px;
    }
    .admin-filter-line{
      display:flex;
      flex-wrap:wrap;
      align-items:flex-end;
      gap:10px;
    }
    .admin-filter-line label{
      display:flex;
      flex-direction:column;
      font-size:12px;
      color:var(--muted);
    }
    .admin-filter-line select{
      margin-top:2px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid #d1d5db;
      font-size:13px;
      outline:none;
      background:#ffffff;
    }
    .admin-filter-line select:focus{
      border-color:var(--brand);
      box-shadow:0 0 0 2px var(--ring);
    }
    .admin-last-update{
      font-size:12px;
      color:var(--muted);
      margin-left:auto;
      display:flex;
      align-items:center;
      gap:8px;
    }

    .toggle-incomplete{
      display:inline-flex;
      align-items:center;
      gap:4px;
      font-size:12px;
      color:var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .toggle-incomplete input{
      margin:0;
    }

    .admin-error{
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      background:#fef2f2;
      border:1px solid #fecaca;
      font-size:13px;
      color:#991b1b;
    }
    .admin-loading{
      margin-top:8px;
      padding:10px 12px;
      border-radius:12px;
      background:#eff6ff;
      border:1px solid #bfdbfe;
      font-size:13px;
      color:#1d4ed8;
    }

    .admin-kpis{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
      gap:10px;
      margin-bottom:14px;
    }
    @media (max-width:960px){
      .admin-kpis{ grid-template-columns:repeat(2,minmax(0,1fr)); }
    }

    .kpi{
      padding:10px 12px;
      border-radius:14px;
      background:#ffffff;
      border:1px solid #e2e8f0;
    }
    .kpi-label{
      font-size:11px;
      color:var(--muted);
      margin-bottom:6px;
    }
    .kpi-value{
      font-size:20px;
      font-weight:700;
    }

    .admin-grid{
      display:grid;
      grid-template-columns: minmax(0,1.3fr) minmax(0,1.7fr);
      gap:12px;
      margin-bottom:12px;
    }
    @media (max-width:960px){
      .admin-grid{ grid-template-columns:1fr; }
    }

    .admin-card{
      padding:14px 14px 12px;
    }
    .admin-card h2{
      margin:0 0 4px;
      font-size:16px;
    }
    .admin-small-text{
      font-size:12px;
      color:var(--muted);
      margin-bottom:10px;
    }

    .admin-list{
      display:flex;
      flex-direction:column;
      gap:6px;
      max-height:260px;
      overflow:auto;
    }
    .admin-list-row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      font-size:13px;
      padding:6px 8px;
      border-radius:10px;
      background:#f8fafc;
      border:1px solid #e2e8f0;
      cursor:pointer;
    }
    .admin-list-row:hover{
      background:#e5f0ff;
    }
    .admin-list-row.selected{
      border-color: var(--accent);
      box-shadow:0 0 0 1px rgba(149,202,75,.5);
      background:#ecfdf3;
    }
    .admin-list-label{
      font-weight:500;
    }
    .admin-list-sub{
      font-size:11px;
      color:var(--muted);
    }
    .admin-list-value{
      font-variant-numeric:tabular-nums;
      font-weight:600;
      font-size:12px;
      text-align:right;
    }
    .admin-empty{
      font-size:12px;
      color:var(--muted);
    }

    .table-wrap{
      max-height:260px;
      overflow:auto;
      border-radius:10px;
      border:1px solid #e2e8f0;
      background:#ffffff;
    }
    .admin-table{
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    .admin-table th,
    .admin-table td{
      padding:6px 8px;
      border-bottom:1px solid #e5e7eb;
    }
    .admin-table th{
      text-align:left;
      position:sticky;
      top:0;
      background:#f9fafb;
      z-index:1;
    }
    .admin-table tr:last-child td{
      border-bottom:none;
    }

    .admin-log{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", Courier, monospace;
      font-size:11px;
      background:#020617;
      color:#e5e7eb;
      border-radius:10px;
      padding:10px 12px;
      max-height:240px;
      overflow:auto;
      white-space:pre;
    }

    .admin-side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .btn{
      --bg:#e2e8f0;
      --fg:#0f172a;
      appearance:none;
      border:0;
      border-radius:12px;
      padding:10px 14px;
      font-weight:600;
      cursor:pointer;
      transition: transform .06s ease, box-shadow .2s ease, background .2s;
      box-shadow:0 6px 16px rgba(15,23,42,.08);
      color:var(--fg);
      background:var(--bg);
      font-size:13px;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      --bg:var(--danger);
      --fg:#fff;
    }

    .admin-link{
      color:var(--brand);
      text-decoration:none;
      font-weight:600;
      font-size:13px;
    }
    .admin-link:hover{
      text-decoration:underline;
    }
    code{
      font-size:11px;
      background:#f1f5f9;
      border-radius:4px;
      padding:2px 4px;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      padding:2px 8px;
      border-radius:999px;
      font-size:11px;
      font-weight:600;
    }
    .badge-ok{
      background:#dcfce7;
      color:#166534;
    }
    .badge-warn{
      background:#fef3c7;
      color:#92400e;
    }
  </style>
</head>
<body>
  <div class="shell">
    <nav class="nav card">
      <a class="brand" href="index.html" aria-label="Spre pontaj">
        <img src="favicon.png" alt="Siglă SERVELECT" />
        <div>
          <h1><span>SERVELECT</span><small>Pontaj & Management Concedii</small></h1>
        </div>
      </a>
      <div class="chip">Admin dashboard</div>
    </nav>

    <main class="admin-layout">
      <section class="admin-main">
        <header class="admin-header">
          <h1>Dashboard pontaj</h1>
          <div class="admin-filter-line">
            <label>
              <span>Perioadă</span>
              <select id="rangeSelect">
                <option value="today">Astăzi</option>
                <option value="last7">Ultimele 7 zile</option>
                <option value="all">Toate datele</option>
              </select>
            </label>
            <label>
              <span>Departament</span>
              <select id="deptFilter">
                <option value="all">Toate</option>
              </select>
            </label>
            <label>
              <span>Angajat</span>
              <select id="employeeFilter">
                <option value="all">Toți</option>
              </select>
            </label>
            <div class="admin-last-update">
              <label class="toggle-incomplete">
                <input type="checkbox" id="incompleteOnly" />
                <span>Doar zile incomplete (START / PAUSE / EXTRA deschise)</span>
              </label>
              <span id="lastUpdate">–</span>
            </div>
          </div>
        </header>

        <div id="error" class="admin-error" style="display:none"></div>
        <div id="loading" class="admin-loading">Se încarcă datele din server…</div>

        <section id="dashboard" style="display:none">
          <div class="admin-kpis">
            <div class="card kpi">
              <div class="kpi-label">Pontaje în filtrul curent</div>
              <div class="kpi-value" id="kpiTotal">–</div>
            </div>
            <div class="card kpi">
              <div class="kpi-label">Angajați implicați</div>
              <div class="kpi-value" id="kpiEmployees">–</div>
            </div>
            <div class="card kpi">
              <div class="kpi-label">START</div>
              <div class="kpi-value" id="kpiStart">–</div>
            </div>
            <div class="card kpi">
              <div class="kpi-label">FINISH</div>
              <div class="kpi-value" id="kpiFinish">–</div>
            </div>
            <div class="card kpi">
              <div class="kpi-label">Norme complete (azi)</div>
              <div class="kpi-value" id="kpiCompletedToday">–</div>
            </div>
          </div>

          <div class="admin-grid">
            <section class="card admin-card">
              <h2>Distribuție pe departamente</h2>
              <div class="admin-small-text">Număr de pontaje în perioada și filtrele selectate.</div>
              <div id="deptList" class="admin-list"></div>
            </section>

            <section class="card admin-card">
              <h2 id="lastEventsTitle">Ultimele pontaje</h2>
              <div class="admin-small-text" id="lastEventsHint">
                <span>Perioadă listă:</span>
                <select id="lastEventsRange">
                  <option value="today">Ziua curentă</option>
                  <option value="week">Săptămâna curentă</option>
                  <option value="month">Luna curentă</option>
                  <option value="all">Toate înregistrările</option>
                </select>
                <span id="lastEventsHintText">
                  Toate înregistrările din perioada aleasă, după filtrele de mai sus.
                </span>
              </div>
              <div class="table-wrap">
                <table class="admin-table">
                  <thead>
                    <tr>
                      <th>Data / ora</th>
                      <th>Angajat</th>
                      <th>Departament</th>
                      <th>Acțiune</th>
                      <th>Activitate</th>
                    </tr>
                  </thead>
                  <tbody id="lastEventsBody"></tbody>
                </table>
              </div>
            </section>
          </div>

          <section class="card admin-card">
            <h2>Zile incomplete</h2>
            <div class="admin-small-text">
              Zile în care există probleme de închidere: START fără FINISH, PAUSE fără UNPAUSE, EXTRA START fără EXTRA FINISH sau sesiune rămasă deschisă (după filtrul curent).
            </div>
            <div class="table-wrap">
              <table class="admin-table">
                <thead>
                  <tr>
                    <th>Data</th>
                    <th>Angajat</th>
                    <th>Departament</th>
                    <th>Normă</th>
                    <th>Extra</th>
                    <th>Stare</th>
                  </tr>
                </thead>
                <tbody id="incompleteDaysBody"></tbody>
              </table>
            </div>
          </section>

          <section class="card admin-card">
            <h2 id="rawLogTitle">Log brut (filtru curent)</h2>
            <div class="admin-small-text">
              Lista completă a evenimentelor care trec de filtrele de mai sus — utilă pentru debugging sau verificări rapide.
            </div>
            <pre id="rawLog" class="admin-log">–</pre>
          </section>

          <section class="card admin-card">
            <h2>Prezență pe zile</h2>
            <div class="admin-small-text">
              Pentru perioada și filtrele de mai sus: câți angajați au avut cel puțin un START și câți au normă completă.
            </div>
            <div class="table-wrap">
              <table class="admin-table">
                <thead>
                  <tr>
                    <th>Data</th>
                    <th>Angajați cu pontaj</th>
                    <th>Normă completă</th>
                    <th>% complet</th>
                  </tr>
                </thead>
                <tbody id="dailyPresenceBody"></tbody>
              </table>
            </div>
          </section>

          <div class="admin-grid">
            <section class="card admin-card">
              <h2>Index angajați</h2>
              <div class="admin-small-text">
                Listă angajați (după filtrul de departament). Click pe un nume pentru a vedea statistici detaliate (all time).
              </div>
              <div id="employeeIndexList" class="admin-list"></div>
            </section>

            <section class="card admin-card">
              <h2>Detalii angajat</h2>
              <div class="admin-small-text" id="employeeDetailsHeader">
                Selectează un angajat din listă pentru a vedea situația pe toate zilele (normă, extra, overtime, zile complete).
              </div>
              <div id="employeeDetailsBody">
                <div class="admin-empty">Niciun angajat selectat.</div>
              </div>
            </section>
          </div>
        </section>
      </section>

      <aside class="admin-side">
        <section class="card admin-card">
          <h2>Sesiune admin</h2>
          <p class="admin-small-text">
            Conectat ca <b id="adminLabel">Admin</b>.
          </p>
          <button id="logoutBtn" class="btn primary" type="button">Deconectare</button>
          <button id="exportCsvBtn" class="btn" type="button" style="margin-top:8px">
            Export CSV (filtru curent)
          </button>
          <button id="pdfBtn" class="btn" type="button" style="margin-top:8px">
            PDF angajat selectat
          </button>
          <button id="deptPdfBtn" class="btn" type="button" style="margin-top:8px">
            PDF departament (luna precedentă)
          </button>
          <button id="employeeExportBtn" class="btn" type="button" style="margin-top:8px">
            Export CSV angajat (all time)
          </button>
          <p class="admin-small-text" style="margin-top:10px">
            <a href="index.html" class="admin-link">Înapoi la pontaj</a>
          </p>
        </section>

        <section class="card admin-card">
          <h2>Top angajați</h2>
          <div class="admin-small-text">
            După total ore normă lucrate (all time).
          </div>
          <div id="topEmployees" class="admin-list"></div>
        </section>

        <section class="card admin-card">
          <h2>Notițe</h2>
          <p class="admin-small-text">
            Pagina citește datele prin Apps Script (<code>adminEventsEndpoint</code> din <code>config.json</code>).
            Foaia de pontaj rămâne privată; serverul întoarce un JSON cu evenimente, iar aici calculăm statistici, ore pe zi, overtime și rapoarte PDF.
          </p>
        </section>
      </aside>
    </main>
  </div>

  <script>
  (function(){
    const ADMIN_LS_KEY = 'pontaj/admin/v1';

    let ALL_STATS = null;
    let SELECTED_EMPLOYEE = null;
    let CURRENT_DEPT_FILTER = 'all';
    let filterIncompleteOnly = false;
    let GLOBAL_CFG = null;
    let lastEventsRange = 'today';

    function getAdminSession(){
      try{
        const raw = localStorage.getItem(ADMIN_LS_KEY);
        return raw ? JSON.parse(raw) : null;
      }catch{ return null; }
    }
    function clearAdminSession(){
      try{ localStorage.removeItem(ADMIN_LS_KEY); }catch{}
    }

    async function loadConfig(){
      if (GLOBAL_CFG) return GLOBAL_CFG;
      const r = await fetch('config.json?v=' + Date.now(), {cache:'no-store'});
      if (!r.ok) throw new Error('Nu pot citi config.json (HTTP ' + r.status + ').');
      GLOBAL_CFG = await r.json();
      return GLOBAL_CFG;
    }

    const session = getAdminSession();
    const adminLabelEl = document.getElementById('adminLabel');
    const logoutBtn = document.getElementById('logoutBtn');
    const errorEl = document.getElementById('error');
    const loadingEl = document.getElementById('loading');
    const dashboardEl = document.getElementById('dashboard');
    const rangeSelect = document.getElementById('rangeSelect');
    const deptFilter = document.getElementById('deptFilter');
    const employeeFilter = document.getElementById('employeeFilter');
    const incompleteOnlyCheckbox = document.getElementById('incompleteOnly');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const rawLogEl = document.getElementById('rawLog');
    const exportCsvBtn = document.getElementById('exportCsvBtn');
    const pdfBtn = document.getElementById('pdfBtn');
    const deptPdfBtn = document.getElementById('deptPdfBtn');
    const employeeExportBtn = document.getElementById('employeeExportBtn');
    const topEmployeesEl = document.getElementById('topEmployees');
    const employeeIndexListEl = document.getElementById('employeeIndexList');
    const employeeDetailsHeaderEl = document.getElementById('employeeDetailsHeader');
    const employeeDetailsBodyEl = document.getElementById('employeeDetailsBody');
    const kpiCompletedTodayEl = document.getElementById('kpiCompletedToday');
    const dailyPresenceBodyEl = document.getElementById('dailyPresenceBody');
    const incompleteDaysBodyEl = document.getElementById('incompleteDaysBody');
    const lastEventsTitleEl = document.getElementById('lastEventsTitle');
    const lastEventsHintTextEl = document.getElementById('lastEventsHintText');
    const lastEventsRangeSelect = document.getElementById('lastEventsRange');
    const rawLogTitleEl = document.getElementById('rawLogTitle');

    if (!session){
      alert('Nu ești autentificat ca admin. Te redirecționez la pagina principală.');
      window.location.href = 'index.html';
      return;
    }
    if (adminLabelEl) adminLabelEl.textContent = session.user || 'Admin';
    if (logoutBtn){
      logoutBtn.addEventListener('click', function(){
        clearAdminSession();
        window.location.href = 'index.html';
      });
    }

    function showError(msg){
      if (errorEl){
        errorEl.textContent = msg;
        errorEl.style.display = 'block';
      }
      if (loadingEl) loadingEl.style.display = 'none';
      if (dashboardEl) dashboardEl.style.display = 'none';
    }

    function _norm(s){ return String(s==null?'':s).trim(); }
    function _normAction(a){
      let s = _norm(a).toLowerCase().replace(/[-\s]+/g,'_');
      if (s === 'resume') s='unpause';
      if (s === 'stop') s='finish';
      if (s === 'extra start') s='extra_start';
      if (s === 'extra finish') s='extra_finish';
      return s;
    }
    function fmtDateTime(iso){
      if (!iso) return '';
      const d = new Date(iso);
      if (isNaN(d.getTime())) return '';
      const dd = String(d.getDate()).padStart(2,'0');
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const yyyy = d.getFullYear();
      const hh = String(d.getHours()).padStart(2,'0');
      const mi = String(d.getMinutes()).padStart(2,'0');
      return `${dd}.${mm}.${yyyy} ${hh}:${mi}`;
    }
    function fmtHoursShort(ms){
      const h = ms / 3600000;
      return h.toFixed(1).replace('.', ',') + ' h';
    }
    function fmtHoursHM(ms){
      const totalMin = Math.round(ms / 60000);
      const h = Math.floor(totalMin / 60);
      const m = totalMin % 60;
      return `${h}h ${String(m).padStart(2,'0')}m`;
    }
    function msToHours(ms){
      return ms / 3600000;
    }
    function dateKeyFromIso(iso){
      if (!iso) return null;
      const d = new Date(iso);
      if (isNaN(d.getTime())) return null;
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const dd = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}`;
    }

    function renderKpis(events){
      const totalEl = document.getElementById('kpiTotal');
      const empEl = document.getElementById('kpiEmployees');
      const startEl = document.getElementById('kpiStart');
      const finishEl = document.getElementById('kpiFinish');
      const list = events || [];
      if (totalEl) totalEl.textContent = String(list.length);
      const uniq = new Set();
      let cStart = 0, cFinish = 0;
      list.forEach(ev => {
        if (ev.name) uniq.add(ev.name);
        if (ev.action === 'start') cStart++;
        if (ev.action === 'finish') cFinish++;
      });
      if (empEl) empEl.textContent = String(uniq.size);
      if (startEl) startEl.textContent = String(cStart);
      if (finishEl) finishEl.textContent = String(cFinish);
    }

    function renderDept(events){
      const container = document.getElementById('deptList');
      if (!container) return;
      const list = events || [];
      if (!list.length){
        container.innerHTML = '<div class="admin-empty">Nu există date în filtrul curent.</div>';
        return;
      }
      const counts = {};
      list.forEach(ev => {
        const key = ev.dept || '(fără departament)';
        counts[key] = (counts[key] || 0) + 1;
      });
      const entries = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
      container.innerHTML = '';
      entries.forEach(([dept, count])=>{
        const row = document.createElement('div');
        row.className = 'admin-list-row';
        row.innerHTML =
          '<div>' +
            '<div class="admin-list-label">' + dept + '</div>' +
          '</div>' +
          '<div class="admin-list-value">' + count + '</div>';
        container.appendChild(row);
      });
    }

    function renderLastEvents(events){
      const tbody = document.getElementById('lastEventsBody');
      if (!tbody) return;
      const list = (events || []).slice().sort((a,b)=>{
        const ta = a.ts ? new Date(a.ts).getTime() : 0;
        const tb = b.ts ? new Date(b.ts).getTime() : 0;
        return tb - ta;
      });
      tbody.innerHTML = '';
      if (!list.length){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 5;
        td.textContent = 'Nu există înregistrări în perioada aleasă (după filtre).';
        tr.appendChild(td);
        tbody.appendChild(tr);
        return;
      }
      list.forEach(ev=>{
        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td>' + fmtDateTime(ev.ts) + '</td>' +
          '<td>' + (ev.name || '') + '</td>' +
          '<td>' + (ev.dept || '') + '</td>' +
          '<td>' + (ev.action || '') + '</td>' +
          '<td>' + (ev.activity || '') + '</td>';
        tbody.appendChild(tr);
      });
    }

    function renderRawLog(events){
      if (!rawLogEl) return;
      const list = events || [];
      if (!list.length){
        rawLogEl.textContent = 'Nu există evenimente în filtrul curent.';
        return;
      }
      const sorted = list.slice().sort((a,b)=>{
        const ta = a.ts ? new Date(a.ts).getTime() : 0;
        const tb = b.ts ? new Date(b.ts).getTime() : 0;
        return ta - tb;
      });
      const lines = sorted.map(ev => {
        const t = fmtDateTime(ev.ts);
        const dept = ev.dept || '';
        const name = ev.name || '';
        const action = ev.action || '';
        const act = ev.activity || '';
        const loc = ev.location || '';
        let s = `[${t}] ${name}`;
        if (dept) s += ' | ' + dept;
        if (action) s += ' | ' + action;
        if (act) s += ' | ' + act;
        if (loc) s += ' | ' + loc;
        return s;
      });
      rawLogEl.textContent = lines.join('\n');
    }

    function buildDeptFilter(events){
      if (!deptFilter) return;
      const set = new Set();
      events.forEach(ev => {
        const key = ev.dept || '(fără departament)';
        if (key) set.add(key);
      });
      const depts = Array.from(set).sort((a,b)=>a.localeCompare(b,'ro'));
      deptFilter.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = 'all';
      optAll.textContent = 'Toate';
      deptFilter.appendChild(optAll);
      depts.forEach(d => {
        const o = document.createElement('option');
        o.value = d;
        o.textContent = d;
        deptFilter.appendChild(o);
      });
    }

    function buildEmployeeFilter(events, selectedDept){
      if (!employeeFilter) return;
      const set = new Set();
      events.forEach(ev => {
        if (!ev.name) return;
        const deptKey = ev.dept || '(fără departament)';
        if (selectedDept && selectedDept !== 'all' && deptKey !== selectedDept) return;
        set.add(ev.name);
      });
      const emps = Array.from(set).sort((a,b)=>a.localeCompare(b,'ro'));
      employeeFilter.innerHTML = '';
      const optAll = document.createElement('option');
      optAll.value = 'all';
      optAll.textContent = 'Toți';
      employeeFilter.appendChild(optAll);
      emps.forEach(n => {
        const o = document.createElement('option');
        o.value = n;
        o.textContent = n;
        employeeFilter.appendChild(o);
      });
    }

    function exportCsv(events){
      const list = events || [];
      if (!list.length){
        alert('Nu există evenimente în filtrul curent pentru export.');
        return;
      }
      const header = ['timestamp_iso','data_ora','nume','departament','actiune','activitate','locatie'];
      const rows = list.map(ev => [
        ev.ts || '',
        fmtDateTime(ev.ts) || '',
        ev.name || '',
        ev.dept || '',
        ev.action || '',
        ev.activity || '',
        ev.location || ''
      ]);
      const csvLines = [header].concat(rows).map(row => row.map(cell => {
        const s = String(cell).replace(/"/g,'""');
        return '"' + s + '"';
      }).join(','));
      const csv = csvLines.join('\r\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'pontaj-export.csv';
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 0);
    }

    // --- helper: zi incompletă (folosim global ALL_STATS) ---
    function isDayIncomplete(day){
      if (!day) return false;
      const hasAnyActivity =
        day.hasStart || day.hasFinish ||
        (day.workMs && day.workMs > 0) ||
        (day.extraMs && day.extraMs > 0) ||
        day.openRunning || day.openPause || day.openExtra ||
        day.hasPauseWithoutUnpause || day.hasExtraStartWithoutFinish;
      if (!hasAnyActivity) return false;
      if (day.completed) return false;

      if (day.hasStart && !day.hasFinish) return true;
      if (day.hasFinish && !day.hasStart) return true; // caz ciudat dar îl marcăm
      if (day.openRunning || day.openPause || day.openExtra) return true;
      if (day.hasPauseWithoutUnpause) return true;
      if (day.hasExtraStartWithoutFinish) return true;
      return false;
    }

    // === STATISTICI ALL-TIME & PE PERIOADĂ ===
    function buildStatsFromEvents(events){
      const employees = new Map();
      const perDay = new Map();
      const NORM_MS = 8 * 60 * 60 * 1000;

      function getEmp(name){
        if (!employees.has(name)){
          employees.set(name, {
            name,
            dept:'',
            days:new Map(),
            totals:{
              daysWithStart:0,
              daysWithFinish:0,
              daysCompleted:0,
              totalWorkMs:0,
              totalExtraMs:0,
              overtimeMs:0,
              firstEvent:null,
              lastEvent:null
            }
          });
        }
        return employees.get(name);
      }

      const byNameDate = new Map();
      (events || []).forEach(ev => {
        if (!ev.ts || !ev.name) return;
        const dk = dateKeyFromIso(ev.ts);
        if (!dk) return;
        const key = ev.name + '||' + dk;
        if (!byNameDate.has(key)) byNameDate.set(key, []);
        byNameDate.get(key).push(ev);
      });

      byNameDate.forEach((evs, key) => {
        evs.sort((a,b)=>new Date(a.ts) - new Date(b.ts));
        const parts = key.split('||');
        const name = parts[0];
        const dk = parts[1];

        const emp = getEmp(name);
        let day = emp.days.get(dk);
        if (!day){
          day = {
            dateKey: dk,
            dept:'',
            events: evs,
            workMs:0,
            extraMs:0,
            hasStart:false,
            hasFinish:false,
            completed:false,
            overtimeMs:0,
            openRunning:false,
            openPause:false,
            openExtra:false,
            hasPauseWithoutUnpause:false,
            hasExtraStartWithoutFinish:false
          };
          emp.days.set(dk, day);
        }

        evs.forEach(ev => {
          if (ev.dept) day.dept = ev.dept;
        });
        if (!emp.dept && day.dept) emp.dept = day.dept;

        let running = false;
        let paused = false;
        let extraRunning = false;
        let startTs = null;
        let pauseStartTs = null;
        let extraStartTs = null;
        let sumPauseMs = 0;
        let workMs = 0;
        let extraMs = 0;

        let pauseDepth = 0;
        let extraDepth = 0;
        let pauseAnomaly = false;
        let extraAnomaly = false;

        evs.forEach(ev => {
          const t = new Date(ev.ts).getTime();
          if (isNaN(t)) return;
          const act = ev.action;
          if (act === 'start') {
            day.hasStart = true;
            if (!running) {
              running = true;
              paused = false;
              sumPauseMs = 0;
              startTs = t;
              pauseStartTs = null;
            }
          } else if (act === 'pause') {
            pauseDepth++;
            if (running && !paused) {
              paused = true;
              pauseStartTs = t;
            }
          } else if (act === 'unpause') {
            if (pauseDepth > 0) {
              pauseDepth--;
            }
            if (running && paused) {
              paused = false;
              if (pauseStartTs != null) {
                sumPauseMs += Math.max(0, t - pauseStartTs);
                pauseStartTs = null;
              }
            }
          } else if (act === 'finish') {
            day.hasFinish = true;
            if (running && startTs != null) {
              if (paused && pauseStartTs != null) {
                sumPauseMs += Math.max(0, t - pauseStartTs);
                pauseStartTs = null;
                paused = false;
              }
              const diff = Math.max(0, t - startTs);
              const segment = Math.max(0, diff - sumPauseMs);
              workMs += segment;
            }
            running = false;
            paused = false;
            startTs = null;
            pauseStartTs = null;
            sumPauseMs = 0;

            if (pauseDepth > 0) {
              pauseAnomaly = true;
              pauseDepth = 0;
            }
          } else if (act === 'extra_start') {
            extraDepth++;
            if (!extraRunning) {
              extraRunning = true;
              extraStartTs = t;
            }
          } else if (act === 'extra_finish') {
            if (extraDepth > 0) {
              extraDepth--;
            }
            if (extraRunning && extraStartTs != null) {
              extraMs += Math.max(0, t - extraStartTs);
            }
            extraRunning = false;
            extraStartTs = null;
          }
        });

        if (pauseDepth > 0) {
          pauseAnomaly = true;
          pauseDepth = 0;
        }
        if (extraDepth > 0) {
          extraAnomaly = true;
          extraDepth = 0;
        }

        day.workMs = workMs;
        day.extraMs = extraMs;
        day.openRunning = running;
        day.openPause = paused;
        day.openExtra = extraRunning;
        day.hasPauseWithoutUnpause = pauseAnomaly;
        day.hasExtraStartWithoutFinish = extraAnomaly;

        if (day.hasStart) emp.totals.daysWithStart++;
        if (day.hasFinish) emp.totals.daysWithFinish++;
        if (day.hasStart && day.hasFinish && workMs > 0) {
          day.completed = true;
          emp.totals.daysCompleted++;
          if (workMs > NORM_MS) {
            day.overtimeMs = workMs - NORM_MS;
            emp.totals.overtimeMs += day.overtimeMs;
          }
        }
        emp.totals.totalWorkMs += workMs;
        emp.totals.totalExtraMs += extraMs;

        evs.forEach(ev => {
          const t = new Date(ev.ts).getTime();
          if (isNaN(t)) return;
          if (!emp.totals.firstEvent || t < new Date(emp.totals.firstEvent).getTime()) {
            emp.totals.firstEvent = ev.ts;
          }
          if (!emp.totals.lastEvent || t > new Date(emp.totals.lastEvent).getTime()) {
            emp.totals.lastEvent = ev.ts;
          }
        });

        let daySummary = perDay.get(dk);
        if (!daySummary) {
          daySummary = { dateKey: dk, started: new Set(), completed: new Set() };
          perDay.set(dk, daySummary);
        }
        if (day.hasStart) daySummary.started.add(name);
        if (day.completed) daySummary.completed.add(name);
      });

      return { employees, perDay };
    }

    function renderEmployeeIndex(allStats, deptFilterValue){
      if (!employeeIndexListEl) return;
      if (!allStats || !allStats.employees){
        employeeIndexListEl.innerHTML = '<div class="admin-empty">Nu există date.</div>';
        return;
      }
      const entries = [];
      allStats.employees.forEach((emp) => {
        const dept = emp.dept || '(fără departament)';
        if (deptFilterValue && deptFilterValue !== 'all' && dept !== deptFilterValue) return;
        entries.push(emp);
      });
      if (!entries.length){
        employeeIndexListEl.innerHTML = '<div class="admin-empty">Nu există angajați pentru acest departament.</div>';
        return;
      }
      entries.sort((a,b)=>b.totals.totalWorkMs - a.totals.totalWorkMs);
      employeeIndexListEl.innerHTML = '';
      entries.forEach(emp => {
        const row = document.createElement('div');
        row.className = 'admin-list-row';
        row.dataset.empName = emp.name;
        const dept = emp.dept || '(fără departament)';
        const t = emp.totals;
        row.innerHTML =
          '<div>' +
            '<div class="admin-list-label">' + emp.name + '</div>' +
            '<div class="admin-list-sub">' + dept + ' • ' +
              t.daysCompleted + ' zile complete, ' + fmtHoursShort(t.totalWorkMs) +
            '</div>' +
          '</div>' +
          '<div class="admin-list-value">' +
            '<span>' + fmtHoursShort(t.totalWorkMs) + '</span>' +
          '</div>';
        row.addEventListener('click', function(){
          SELECTED_EMPLOYEE = emp.name;
          if (employeeFilter){
            if (!employeeFilter.querySelector('option[value="'+emp.name+'"]')){
              const o = document.createElement('option');
              o.value = emp.name;
              o.textContent = emp.name;
              employeeFilter.appendChild(o);
            }
            employeeFilter.value = emp.name;
          }
          markSelectedEmployee(emp.name);
          renderEmployeeDetails(emp.name);
        });
        employeeIndexListEl.appendChild(row);
      });
    }

    function markSelectedEmployee(name){
      document.querySelectorAll('.admin-list-row').forEach(el => {
        el.classList.toggle('selected', el.dataset.empName === name);
      });
    }

    function renderEmployeeDetails(name){
      if (!employeeDetailsBodyEl || !employeeDetailsHeaderEl) return;
      if (!name){
        employeeDetailsHeaderEl.textContent = 'Selectează un angajat din listă pentru a vedea situația pe toate zilele.';
        employeeDetailsBodyEl.innerHTML = '<div class="admin-empty">Niciun angajat selectat.</div>';
        return;
      }
      if (!ALL_STATS || !ALL_STATS.employees || !ALL_STATS.employees.has(name)){
        employeeDetailsHeaderEl.textContent = 'Nu găsesc statistici pentru ' + name + '.';
        employeeDetailsBodyEl.innerHTML = '<div class="admin-empty">Nu există date pentru acest angajat.</div>';
        return;
      }
      const emp = ALL_STATS.employees.get(name);
      const dept = emp.dept || '(fără departament)';
      const t = emp.totals;
      employeeDetailsHeaderEl.innerHTML =
        'Statistici all time pentru <b>' + name + '</b> (' + dept + '). ' +
        'Zile cu normă completă: <b>' + t.daysCompleted + '</b> din <b>' + t.daysWithStart + '</b> cu START.';
      const daysArr = Array.from(emp.days.values()).sort((a,b)=>a.dateKey < b.dateKey ? -1 : (a.dateKey > b.dateKey ? 1 : 0));

      let html = '';
      html += '<div style="margin-bottom:10px;font-size:13px;">';
      html += '<div><b>Total ore normă:</b> ' + fmtHoursShort(t.totalWorkMs) + '</div>';
      html += '<div><b>Total ore extra:</b> ' + fmtHoursShort(t.totalExtraMs) + '</div>';
      html += '<div><b>Total overtime:</b> ' + fmtHoursShort(t.overtimeMs) + '</div>';
      html += '<div><b>Zile cu START:</b> ' + t.daysWithStart + ' • <b>Zile cu FINISH:</b> ' + t.daysWithFinish + '</div>';
      html += '</div>';

      if (!daysArr.length){
        html += '<div class="admin-empty">Nu există zile înregistrate pentru acest angajat.</div>';
        employeeDetailsBodyEl.innerHTML = html;
        return;
      }

      html += '<div class="table-wrap">';
      html += '<table class="admin-table">';
      html += '<thead><tr>' +
        '<th>Data</th>' +
        '<th>Departament</th>' +
        '<th>Normă</th>' +
        '<th>Extra</th>' +
        '<th>Completă</th>' +
        '<th>Overtime</th>' +
      '</tr></thead><tbody>';
      daysArr.forEach(d => {
        const status = d.completed
          ? '<span class="badge badge-ok">DA</span>'
          : (d.hasStart || d.hasFinish || d.workMs || d.extraMs)
            ? '<span class="badge badge-warn">INCOMPLETĂ</span>'
            : '-';
        html += '<tr>' +
          '<td>' + d.dateKey + '</td>' +
          '<td>' + (d.dept || '') + '</td>' +
          '<td>' + (d.workMs ? fmtHoursHM(d.workMs) : '-') + '</td>' +
          '<td>' + (d.extraMs ? fmtHoursHM(d.extraMs) : '-') + '</td>' +
          '<td>' + status + '</td>' +
          '<td>' + (d.overtimeMs ? fmtHoursHM(d.overtimeMs) : '-') + '</td>' +
        '</tr>';
      });
      html += '</tbody></table></div>';

      employeeDetailsBodyEl.innerHTML = html;
    }

    function renderTopEmployees(allStats){
      if (!topEmployeesEl) return;
      if (!allStats || !allStats.employees){
        topEmployeesEl.innerHTML = '<div class="admin-empty">Nu există date.</div>';
        return;
      }
      const entries = [];
      allStats.employees.forEach((emp) => {
        entries.push(emp);
      });
      if (!entries.length){
        topEmployeesEl.innerHTML = '<div class="admin-empty">Nu există date.</div>';
        return;
      }
      entries.sort((a,b)=>b.totals.totalWorkMs - a.totals.totalWorkMs);
      const top = entries.slice(0,5);
      topEmployeesEl.innerHTML = '';
      top.forEach(emp => {
        const t = emp.totals;
        const row = document.createElement('div');
        row.className = 'admin-list-row';
        row.dataset.empName = emp.name;
        row.innerHTML =
          '<div>' +
            '<div class="admin-list-label">' + emp.name + '</div>' +
            '<div class="admin-list-sub">' + (emp.dept || '(fără departament)') + '</div>' +
          '</div>' +
          '<div class="admin-list-value">' +
            '<div>' + fmtHoursShort(t.totalWorkMs) + '</div>' +
            '<div style="font-size:11px;color:#6b7280;">' + t.daysCompleted + ' zile complete</div>' +
          '</div>';
        row.addEventListener('click', function(){
          SELECTED_EMPLOYEE = emp.name;
          markSelectedEmployee(emp.name);
          renderEmployeeDetails(emp.name);
        });
        topEmployeesEl.appendChild(row);
      });
    }

    function filterByRange(events, range){
      if (!events || !events.length) return [];
      const now = new Date();
      if (range === 'all') return events.slice();
      const endTime = now.getTime();
      let startTime;
      if (range === 'last7'){
        const d = new Date(now);
        d.setDate(d.getDate() - 6);
        startTime = d.getTime();
      } else { // today
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0);
        startTime = d.getTime();
      }
      return events.filter(ev => {
        if (!ev.ts) return false;
        const t = new Date(ev.ts).getTime();
        if (isNaN(t)) return false;
        return t >= startTime && t <= endTime;
      });
    }

    function filterLastEventsByRange(events, range){
      if (!events || !events.length) return [];
      const now = new Date();
      const endTime = now.getTime();
      let startTime = null;

      if (range === 'today'){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0);
        startTime = d.getTime();
      } else if (range === 'week'){
        const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0);
        const day = d.getDay(); // 0=Sun, 1=Mon...
        const diffToMonday = (day + 6) % 7;
        d.setDate(d.getDate() - diffToMonday);
        startTime = d.getTime();
      } else if (range === 'month'){
        const d = new Date(now.getFullYear(), now.getMonth(), 1, 0,0,0);
        startTime = d.getTime();
      } else { // all
        return events.slice();
      }

      return events.filter(ev => {
        if (!ev.ts) return false;
        const t = new Date(ev.ts).getTime();
        if (isNaN(t)) return false;
        return t >= startTime && t <= endTime;
      });
    }

    function updateCompletedTodayKpiFromStats(stats, range){
      if (!kpiCompletedTodayEl) return;
      if (range !== 'today'){
        kpiCompletedTodayEl.textContent = '–';
        return;
      }
      if (!stats || !stats.employees || !stats.employees.size){
        kpiCompletedTodayEl.textContent = '0 / 0';
        return;
      }
      let total = 0, completed = 0;
      stats.employees.forEach(emp => {
        const t = emp.totals;
        if (t.daysWithStart || t.daysWithFinish){
          total++;
          if (t.daysCompleted > 0) completed++;
        }
      });
      kpiCompletedTodayEl.textContent = completed + ' / ' + total;
    }

    function renderDailyPresence(stats){
      if (!dailyPresenceBodyEl) return;
      dailyPresenceBodyEl.innerHTML = '';
      if (!stats || !stats.perDay || !stats.perDay.size){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 4;
        td.textContent = 'Nu există zile în filtrul curent.';
        tr.appendChild(td);
        dailyPresenceBodyEl.appendChild(tr);
        return;
      }
      const entries = Array.from(stats.perDay.values())
        .sort((a,b)=>a.dateKey < b.dateKey ? -1 : (a.dateKey > b.dateKey ? 1 : 0));
      entries.forEach(day => {
        const started = day.started ? day.started.size : 0;
        const completed = day.completed ? day.completed.size : 0;
        const pct = started ? Math.round(100 * completed / started) : 0;
        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td>' + day.dateKey + '</td>' +
          '<td>' + started + '</td>' +
          '<td>' + completed + '</td>' +
          '<td>' + (started ? pct + '%' : '–') + '</td>';
        dailyPresenceBodyEl.appendChild(tr);
      });
    }

    function renderIncompleteDays(baseEvents){
      if (!incompleteDaysBodyEl) return;
      incompleteDaysBodyEl.innerHTML = '';

      if (!baseEvents || !baseEvents.length || !ALL_STATS || !ALL_STATS.employees || !ALL_STATS.employees.size){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 6;
        td.textContent = 'Nu există zile incomplete în filtrul curent.';
        tr.appendChild(td);
        incompleteDaysBodyEl.appendChild(tr);
        return;
      }

      const keyMap = new Map(); // key -> {name, dateKey, deptHint}
      baseEvents.forEach(ev => {
        if (!ev.name || !ev.ts) return;
        const dk = dateKeyFromIso(ev.ts);
        if (!dk) return;
        const key = ev.name + '||' + dk;
        if (!keyMap.has(key)){
          keyMap.set(key, {
            name: ev.name,
            dateKey: dk,
            deptHint: ev.dept || ''
          });
        }
      });

      const rows = [];
      keyMap.forEach(info => {
        const emp = ALL_STATS.employees.get(info.name);
        if (!emp) return;
        const day = emp.days.get(info.dateKey);
        if (!day) return;
        if (!isDayIncomplete(day)) return;
        rows.push({
          dateKey: info.dateKey,
          name: info.name,
          dept: day.dept || emp.dept || info.deptHint || '',
          workMs: day.workMs,
          extraMs: day.extraMs,
          day
        });
      });

      if (!rows.length){
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 6;
        td.textContent = 'Nu există zile incomplete în filtrul curent.';
        tr.appendChild(td);
        incompleteDaysBodyEl.appendChild(tr);
        return;
      }

      rows.sort((a,b)=>{
        if (a.dateKey < b.dateKey) return -1;
        if (a.dateKey > b.dateKey) return 1;
        if (a.name < b.name) return -1;
        if (a.name > b.name) return 1;
        return 0;
      });

      rows.forEach(item => {
        const d = item.day;
        const statusParts = [];
        if (d.hasStart && !d.hasFinish) statusParts.push('START fără FINISH');
        if (d.hasFinish && !d.hasStart) statusParts.push('FINISH fără START');
        if (d.hasPauseWithoutUnpause) statusParts.push('PAUSE fără UNPAUSE');
        if (d.hasExtraStartWithoutFinish) statusParts.push('EXTRA START fără EXTRA FINISH');
        if (d.openRunning) statusParts.push('Sesiune normă încă deschisă');
        if (d.openPause) statusParts.push('În PAUSE la finalul zilei');
        if (d.openExtra) statusParts.push('Sesiune EXTRA încă deschisă');
        const statusText = statusParts.length ? statusParts.join(' • ') : 'Incompletă';

        const tr = document.createElement('tr');
        tr.innerHTML =
          '<td>' + item.dateKey + '</td>' +
          '<td>' + item.name + '</td>' +
          '<td>' + item.dept + '</td>' +
          '<td>' + (item.workMs ? fmtHoursHM(item.workMs) : '-') + '</td>' +
          '<td>' + (item.extraMs ? fmtHoursHM(item.extraMs) : '-') + '</td>' +
          '<td>' + statusText + '</td>';
        incompleteDaysBodyEl.appendChild(tr);
      });
    }

    function applyDeptEmployee(events, currentDept, currentEmployee){
      let list = events.slice();
      if (currentDept && currentDept !== 'all'){
        list = list.filter(ev => (ev.dept || '(fără departament)') === currentDept);
      }
      if (currentEmployee && currentEmployee !== 'all'){
        list = list.filter(ev => ev.name === currentEmployee);
      }
      return list;
    }

    function applyIncompleteFilter(events){
      if (!filterIncompleteOnly) return events;
      if (!ALL_STATS || !ALL_STATS.employees || !events || !events.length) return events;
      return events.filter(ev => {
        if (!ev.name || !ev.ts) return false;
        const dk = dateKeyFromIso(ev.ts);
        if (!dk) return false;
        const emp = ALL_STATS.employees.get(ev.name);
        if (!emp) return false;
        const day = emp.days.get(dk);
        if (!day) return false;
        return isDayIncomplete(day);
      });
    }

    async function init(){
      try{
        const CFG = await loadConfig();
        if (!CFG || !CFG.adminEventsEndpoint){
          throw new Error('config.json nu conține adminEventsEndpoint.');
        }

        const adminUrl = CFG.adminEventsEndpoint + '?fn=adminEvents&v=' + Date.now();
        const r2 = await fetch(adminUrl, { cache:'no-store' });
        const txt = await r2.text();
        let data;
        try { data = JSON.parse(txt); } catch(e){ throw new Error('Răspuns invalid de la adminEventsEndpoint.'); }
        if (!data || !data.ok || !Array.isArray(data.events)){
          throw new Error('adminEventsEndpoint nu a întors un obiect ok cu events[].');
        }

        const meta = data.meta || null;
        window.__pontajAdminMeta = meta || null;

        const events = data.events.map(ev => ({
          ts: ev.ts,
          name: ev.name || '',
          action: _normAction(ev.action),
          dept: ev.dept || '',
          activity: ev.activity || '',
          location: ev.location || ''
        })).filter(ev => ev.ts);

        if (loadingEl) loadingEl.style.display = 'none';
        if (dashboardEl) dashboardEl.style.display = '';

        if (lastUpdateEl){
          let stamp = new Date();
          if (meta && meta.generatedAt){
            const dMeta = new Date(meta.generatedAt);
            if (!isNaN(dMeta.getTime())) {
              stamp = dMeta;
            }
          }
          const hh = String(stamp.getHours()).padStart(2,'0');
          const mi = String(stamp.getMinutes()).padStart(2,'0');
          lastUpdateEl.textContent = 'Actualizat la ' + hh + ':' + mi;
        }

        // ALL_STATS = statistici all-time, din toate evenimentele
        ALL_STATS = buildStatsFromEvents(events);
        renderTopEmployees(ALL_STATS);

        let currentRange = rangeSelect ? rangeSelect.value : 'today';
        let currentDept = 'all';
        let currentEmployee = 'all';
        let latestFiltered = [];

        buildDeptFilter(events);
        buildEmployeeFilter(events, currentDept);
        renderEmployeeIndex(ALL_STATS, CURRENT_DEPT_FILTER);
        renderEmployeeDetails(null);

        function refresh(){
          // 1) Pentru KPI, log, prezență, zile incomplete: folosim rangeSelect
          let baseAll = applyDeptEmployee(events, currentDept, currentEmployee);
          let baseRange = filterByRange(baseAll, currentRange || 'today');
          let filteredForMain = applyIncompleteFilter(baseRange);
          latestFiltered = filteredForMain;

          renderKpis(filteredForMain);
          renderDept(filteredForMain);
          renderRawLog(filteredForMain);

          const statsBase = buildStatsFromEvents(baseRange);
          updateCompletedTodayKpiFromStats(statsBase, currentRange);
          renderDailyPresence(statsBase);
          renderIncompleteDays(baseRange);

          // 2) Pentru „Ultimele pontaje”: range propriu (lastEventsRange)
          let lastBase = applyDeptEmployee(events, currentDept, currentEmployee);
          let lastByRange = filterLastEventsByRange(lastBase, lastEventsRange || 'today');
          let lastFinal = applyIncompleteFilter(lastByRange);
          renderLastEvents(lastFinal);

          // 3) Titluri când este bifat "doar zile incomplete"
          if (lastEventsTitleEl && lastEventsHintTextEl && rawLogTitleEl){
            if (filterIncompleteOnly){
              lastEventsTitleEl.textContent = 'Ultimele pontaje (doar zile incomplete)';
              lastEventsHintTextEl.textContent =
                'Toate înregistrările din zilele problematice (START/PAUSE/EXTRA neînchise) pentru perioada aleasă și filtrul curent.';
              rawLogTitleEl.textContent = 'Log brut (doar zile incomplete)';
            } else {
              lastEventsTitleEl.textContent = 'Ultimele pontaje';
              lastEventsHintTextEl.textContent =
                'Toate înregistrările din perioada aleasă, după filtrele de mai sus.';
              rawLogTitleEl.textContent = 'Log brut (filtru curent)';
            }
          }
        }

        if (rangeSelect){
          rangeSelect.addEventListener('change', function(){
            currentRange = rangeSelect.value || 'today';
            refresh();
          });
        }
        if (deptFilter){
          deptFilter.addEventListener('change', function(){
            currentDept = deptFilter.value || 'all';
            CURRENT_DEPT_FILTER = currentDept;
            buildEmployeeFilter(events, currentDept);
            if (currentEmployee !== 'all' && employeeFilter){
              if (!employeeFilter.querySelector('option[value="'+currentEmployee+'"]')){
                const o = document.createElement('option');
                o.value = currentEmployee;
                o.textContent = currentEmployee;
                employeeFilter.appendChild(o);
              }
              employeeFilter.value = currentEmployee;
            }
            renderEmployeeIndex(ALL_STATS, CURRENT_DEPT_FILTER);
            renderEmployeeDetails(SELECTED_EMPLOYEE);
            refresh();
          });
        }
        if (employeeFilter){
          employeeFilter.addEventListener('change', function(){
            currentEmployee = employeeFilter.value || 'all';
            if (currentEmployee === 'all'){
              SELECTED_EMPLOYEE = null;
              renderEmployeeDetails(null);
            } else {
              SELECTED_EMPLOYEE = currentEmployee;
              markSelectedEmployee(SELECTED_EMPLOYEE);
              renderEmployeeDetails(SELECTED_EMPLOYEE);
            }
            refresh();
          });
        }
        if (incompleteOnlyCheckbox){
          incompleteOnlyCheckbox.addEventListener('change', function(){
            filterIncompleteOnly = !!incompleteOnlyCheckbox.checked;
            refresh();
          });
        }
        if (lastEventsRangeSelect){
          lastEventsRangeSelect.addEventListener('change', function(){
            lastEventsRange = lastEventsRangeSelect.value || 'today';
            refresh();
          });
        }

        if (exportCsvBtn){
          exportCsvBtn.addEventListener('click', function(){
            exportCsv(latestFiltered);
          });
        }

        if (pdfBtn){
          pdfBtn.addEventListener('click', async function(){
            if (!SELECTED_EMPLOYEE){
              alert('Selectează mai întâi un angajat din Index sau din filtrul de angajați.');
              return;
            }
            try{
              const cfg = await loadConfig();
              if (!cfg.adminEventsEndpoint) throw new Error('Lipsește adminEventsEndpoint.');
              const url = cfg.adminEventsEndpoint +
                '?fn=adminPdf&name=' + encodeURIComponent(SELECTED_EMPLOYEE) +
                '&v=' + Date.now();
              window.open(url, '_blank');
            }catch(err){
              alert('Eroare configurare PDF: ' + (err && err.message ? err.message : err));
            }
          });
        }

        if (deptPdfBtn){
          deptPdfBtn.addEventListener('click', async function(){
            let dept = CURRENT_DEPT_FILTER && CURRENT_DEPT_FILTER !== 'all'
              ? CURRENT_DEPT_FILTER
              : '';
            if (!dept){
              const listOpts = Array.from(deptFilter ? deptFilter.options : [])
                .map(o => o.value)
                .filter(v => v && v !== 'all');
              const suggestion = listOpts.length ? listOpts[0] : '';
              const input = prompt('Introdu numele departamentului pentru raport (exact cum apare în filtrul de departamente):', suggestion);
              dept = input ? input.trim() : '';
            }
            if (!dept){
              alert('Nu a fost ales niciun departament.');
              return;
            }
            try{
              const cfg = await loadConfig();
              if (!cfg.adminEventsEndpoint) throw new Error('Lipsește adminEventsEndpoint.');
              const url = cfg.adminEventsEndpoint +
                '?fn=adminPdfDept&dept=' + encodeURIComponent(dept) +
                '&v=' + Date.now();
              const r = await fetch(url, {cache:'no-store'});
              const resp = await r.json();
              if (!resp.ok || !resp.url){
                throw new Error(resp.error || 'Nu am primit un URL de raport.');
              }
              window.open(resp.url, '_blank');
            }catch(err){
              alert('Eroare la generarea raportului departamental: ' + (err.message || err));
            }
          });
        }

        if (employeeExportBtn){
          employeeExportBtn.addEventListener('click', function(){
            if (!SELECTED_EMPLOYEE){
              alert('Selectează mai întâi un angajat din Index sau din filtrul de angajați.');
              return;
            }
            if (!ALL_STATS || !ALL_STATS.employees || !ALL_STATS.employees.has(SELECTED_EMPLOYEE)){
              alert('Nu găsesc date pentru acest angajat.');
              return;
            }
            const emp = ALL_STATS.employees.get(SELECTED_EMPLOYEE);
            const t = emp.totals;
            const daysArr = Array.from(emp.days.values())
              .sort((a,b)=>a.dateKey < b.dateKey ? -1 : (a.dateKey > b.dateKey ? 1 : 0));

            const totalNormH = msToHours(t.totalWorkMs);
            const totalExtraH = msToHours(t.totalExtraMs);
            const totalOverH = msToHours(t.overtimeMs);
            const pctComplete = t.daysWithStart ? Math.round(100 * t.daysCompleted / t.daysWithStart) : 0;

            const header = [
              'Nume','Departament','Total ore norma (h)','Total ore extra (h)',
              'Total overtime (h)','Zile cu START','Zile cu FINISH','Zile complete',
              'Procent zile complete (%)','Data','Norma (h)','Extra (h)','Overtime (h)','Complet'
            ];

            const rows = daysArr.map(d => {
              return [
                emp.name,
                emp.dept || '',
                totalNormH.toFixed(2),
                totalExtraH.toFixed(2),
                totalOverH.toFixed(2),
                t.daysWithStart,
                t.daysWithFinish,
                t.daysCompleted,
                pctComplete,
                d.dateKey,
                (msToHours(d.workMs) || 0).toFixed(2),
                (msToHours(d.extraMs) || 0).toFixed(2),
                (msToHours(d.overtimeMs) || 0).toFixed(2),
                d.completed ? 'DA' : ((d.hasStart || d.hasFinish || d.workMs || d.extraMs) ? 'INCOMPLETA' : '-')
              ];
            });

            const csvLines = [header].concat(rows).map(row => row.map(cell => {
              const s = String(cell).replace(/"/g,'""');
              return '"' + s + '"';
            }).join(','));
            const csv = csvLines.join('\r\n');

            const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pontaj-' + SELECTED_EMPLOYEE.replace(/\s+/g,'_') + '.csv';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            }, 0);
          });
        }

        refresh();
      }catch(e){
        showError(e.message || String(e));
      }
    }

    init();
  })();
  </script>
</body>
</html>
