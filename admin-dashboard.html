/*********************** CONFIG GLOBAL ************************/

// 1) Poți pune URL-ul direct aici (fallback):
const DEPARTMENTS_CSV_URL_FALLBACK = 'https://raw.githubusercontent.com/pontaj-servelect/pontaj/main/departments.csv';
// 2) Sau setează din Apps Script > Project Settings > Script Properties o cheie: departmentsCsv
//    care va suprascrie fallback-ul de mai sus.

// Timezone de lucru pentru calcule pe zile (RO)
const TZ_RO = 'Europe/Bucharest';

/*********************** UTILITARE GENERALE ************************/

/*** ====== PONTAJ Spreadsheet (ID-based, safe for WebApp) ====== ***/
var PONTAJ_SHEET_ID_DEFAULT = '1Eq7RMyvyj6lZXnkfnQHT0Ol1Y1f-8Ul3SwdOkCkS8s4';
var PONTAJ_RESPONSES_SHEET_NAME_DEFAULT = 'Răspunsuri la formular 1';

function _pontajSs_() {
  // Works even when the script is not container-bound (WebApp context)
  var props = PropertiesService.getScriptProperties();
  var sid = props.getProperty('PONTAJ_SHEET_ID') || PONTAJ_SHEET_ID_DEFAULT;
  try {
    var active = SpreadsheetApp.getActiveSpreadsheet();
    if (active) return active;
  } catch (e) {}
  if (sid) return SpreadsheetApp.openById(sid);
  throw new Error('Nu pot deschide spreadsheet-ul Pontaj. Setează Script Property PONTAJ_SHEET_ID.');
}
/*** ====== /PONTAJ Spreadsheet ====== ***/


function _norm(s){ return String(s == null ? '' : s).trim(); }
function _deaccent(s){ s=String(s==null?'':s); try{return s.normalize('NFD').replace(/[\u0300-\u036f]/g,'');}catch(e){return s;} }

// — cheie pentru mapare nume->departament (fără diacritice, lowercase, spații unice)
function _normKeyName_(s){
  return _deaccent(_norm(s)).toLowerCase().replace(/\s+/g,' ');
}
// — comparam robust două nume de persoane
function _samePerson(a, b){
  return _normKeyName_(a) === _normKeyName_(b);
}

// — euristică pentru a recunoaște valori care "arată" ca departamente
function _looksLikeDept_(v){
  var x = _norm(v).toLowerCase();
  return /productie|produc(ț|t)ie|marketing|v(a|â)nz(â|a)ri|hr|resurse|financiar|contab|it|suport|logistica|achizit(ii|ii)|proiecte|engineering|sales|support|operations/.test(x);
}

function _normAction(a){
  var s = _norm(a).toLowerCase().replace(/[-\s]+/g,'_');
  if (s === 'resume') s = 'unpause';
  if (s === 'stop')   s = 'finish';
  if (s === 'extra start')  s = 'extra_start';
  if (s === 'extra finish') s = 'extra_finish';
  return s;
}

function _getHeaders(sh){
  if (!sh) throw new Error('Sheet missing');
  var lastCol = sh.getLastColumn();
  if (!lastCol) return [];
  return sh.getRange(1,1,1,lastCol).getValues()[0].map(function(x){ return String(x); });
}
function _findCol(headers, keys){
  if (!headers || !headers.length) return 0;
  var keysN = keys.map(function(k){ return _deaccent(String(k).toLowerCase()); });
  for (var i = 0; i < headers.length; i++) {
    var h = _deaccent(String(headers[i]).toLowerCase());
    for (var k = 0; k < keysN.length; k++) {
      if (h.indexOf(keysN[k]) >= 0) return i + 1;
    }
  }
  return 0;
}

function _toDate(v){
  if (Object.prototype.toString.call(v) === '[object Date]') return isNaN(v) ? null : v;
  if (typeof v === 'string'){
    var s = v.replace(' ', 'T');
    var d = new Date(s);
    if (!isNaN(d)) return d;
  }
  return null;
}
function _num(v){
  if (v === null || v === undefined) return 0;
  if (typeof v === 'number') return isNaN(v) ? 0 : v;
  if (typeof v === 'string'){
    var s = v.trim().replace(',', '.'); var n = parseFloat(s);
    return isNaN(n) ? 0 : n;
  }
  return 0;
}
function _asHours(v){
  if (v === null || v === undefined) return 0;
  if (typeof v === 'number') return v;
  if (Object.prototype.toString.call(v) === '[object Date]'){
    var msInDay = 24 * 3600 * 1000;
    var ms = v.getTime() % msInDay;
    return Math.round((ms / 36e5) * 100) / 100;
  }
  if (typeof v === 'string'){
    var s = v.trim();
    if (/^\d{1,2}:\d{1,2}(:\d{1,2})?$/.test(s)){
      var parts = s.split(':'), h = _num(parts[0]), m = _num(parts[1]), sec = parts[2] ? _num(parts[2]) : 0;
      return Math.round((h + m/60 + sec/3600) * 100) / 100;
    }
    s = s.replace(',', '.'); var n = parseFloat(s);
    return isNaN(n) ? 0 : n;
  }
  return 0;
}
function _round2(n){ return Math.round(n * 100) / 100; }

// === DURATE (Sheets): valoare = fracție din zi (ex: 7h30 = 7.5/24) ===
const DUR_FMT = '[h]"h "mm" min"';

function _minutesToDuration_(mins){
  mins = Number(mins || 0);
  return mins / 1440; // 24*60
}

function _hoursToDuration_(hours){
  var h = _asHours(hours);
  if (!h) return 0;
  var mins = Math.round(h * 60);
  return _minutesToDuration_(mins);
}

// Citește o durată din Sheet (fracție de zi) și o întoarce în minute.
// (acceptă și string-uri gen "7:30" / "7h 30 min" / fallback pe ore zecimale vechi)
function _durationToMinutes_(v){
  if (v === null || v === undefined || v === '') return 0;

  // 1) Durată ca număr (fracție de zi, stil Google Sheets)
  if (typeof v === 'number'){
    if (isNaN(v)) return 0;
    return Math.round(v * 1440); // 24 * 60
  }

  // 2) Durată ca Date (uneori Sheets dă un Date intern pentru durate)
  if (Object.prototype.toString.call(v) === '[object Date]'){
    var msInDay = 86400000;
    var t = v.getTime();
    var rem = ((t % msInDay) + msInDay) % msInDay; // 0..msInDay-1
    return Math.round(rem / 60000); // minute
  }

  // 3) String
  if (typeof v === 'string'){
    var s = v.trim();

    // "H:MM" sau "H:MM:SS"
    if (/^\d{1,4}:\d{1,2}(:\d{1,2})?$/.test(s)){
      var p = s.split(':');
      var hh = _num(p[0]);
      var mm = _num(p[1]);
      var ss = p[2] ? _num(p[2]) : 0;
      return Math.round(hh * 60 + mm + ss / 60);
    }

    // "7h 30 min"
    var m2 = s.match(/(-?\d+)\s*h(?:\s*(\d+)\s*min)?/i);
    if (m2){
      var h2 = _num(m2[1]);
      var m22 = _num(m2[2] || 0);
      return Math.round(h2 * 60 + m22);
    }

    // fallback: ore zecimale (ex 7.5)
    var n = parseFloat(s.replace(',', '.'));
    if (!isNaN(n)) return Math.round(n * 60);
  }

  return 0;
}


function _durationToHours_(v){
  return _round2(_durationToMinutes_(v) / 60);
}

// === FORMAT ORE: "Xh YY min" (din ore zecimale sau valori de tip Date/string) ===
function _hoursToMinutes_(v){
  var h = _asHours(v);
  if (!h) return 0;
  return Math.round(h * 60);
}
function _fmtHM_(v){
  var mins = _hoursToMinutes_(v);
  var sign = mins < 0 ? '-' : '';
  mins = Math.abs(mins);
  var hh = Math.floor(mins / 60);
  var mm = mins % 60;
  var mmStr = (mm < 10 ? '0' : '') + mm;
  return sign + hh + 'h ' + mmStr + ' min';
}
function _fmtMsHM_(ms){
  ms = Number(ms || 0);
  var mins = Math.round(ms / 60000);
  var sign = mins < 0 ? '-' : '';
  mins = Math.abs(mins);
  var hh = Math.floor(mins / 60);
  var mm = mins % 60;
  var mmStr = (mm < 10 ? '0' : '') + mm;
  return sign + hh + 'h ' + mmStr + ' min';
}

function _isActivity(v){
  var a = _norm(v).toLowerCase();
  var set = {
    'atelier':1,'deplasare':1,'pe drum':1,'birou + deplasare':1,
    'birou-lucrare':1,'ofertare':1,'concediu de odihna':1,
    'concediu medical':1,'zi libera legala':1,'birou-administrativ':1,
    'home office':1,'invoire':1,'concediu pentru ore suplimentare':1
  };
  return !!set[a];
}
function _stdHoursForActivity(act){
  var a = _norm(act).toLowerCase();
  if (a === 'atelier' || a === 'deplasare' || a === 'pe drum' || a === 'birou + deplasare') return 8.5;
  return 8.0;
}
function _getResponsesSheet_(ss){
  ss = ss || _pontajSs_();

  // Prefer explicit sheet name
  var props = PropertiesService.getScriptProperties();
  var preferred = props.getProperty('PONTAJ_RESPONSES_SHEET_NAME') || PONTAJ_RESPONSES_SHEET_NAME_DEFAULT;
  if (preferred){
    var sh0 = ss.getSheetByName(preferred);
    if (sh0) return sh0;
  }

  // Fallback: detect by name (responses / raspunsuri)
  var sheets = ss.getSheets();
  for (var i=0;i<sheets.length;i++){
    var nm = String(sheets[i].getName());
    var nmn = _deaccent(nm.toLowerCase());
    if (/responses/.test(nmn) || /raspuns/.test(nmn)) return sheets[i];
  }
  return ss.getSheets()[0];
}


/*********************** INDICATOR (bulină) ************************/

function _removeIndicatorCF_(sh, cInd){
  var rules = sh.getConditionalFormatRules(), keep=[];
  for (var i=0;i<rules.length;i++){
    var r = rules[i], rgs = r.getRanges(), hit=false;
    if (rgs && rgs.length){
      for (var j=0;j<rgs.length;j++){
        var rg = rgs[j];
        if (rg && rg.getColumn() <= cInd && (rg.getColumn()+rg.getNumColumns()-1) >= cInd){ hit=true; break; }
      }
    }
    if (!hit) keep.push(r);
  }
  if (keep.length !== rules.length) sh.setConditionalFormatRules(keep);
}

function paintOneIndicatorRow_(sh, row, cDur, cInd, cAct, cLoc){
  if (!cDur || !cInd || row < 2) return;
  var valDur = sh.getRange(row, cDur).getValue();
  var dur = _asHours(valDur);

  var act = cAct ? _norm(sh.getRange(row, cAct).getDisplayValue()) : '';
  if (!act && cLoc){
    var maybe = _norm(sh.getRange(row, cLoc).getDisplayValue());
    if (_isActivity(maybe)) act = maybe;
  }
  var std = _stdHoursForActivity(act);

  var headers = _getHeaders(sh);
  var cOT = _findCol(headers, ['suplimentar (h)','overtime','suplimentar']);
  if (cOT){
    var ot = Math.max(0, _round2(dur - std));
    sh.getRange(row, cOT).setNumberFormat('0.00').setValue(ot);
  }
  sh.getRange(row, cInd).setValue('');

  var bg = null;
  if (dur > 0){
    if (dur < std) bg = '#F87171';
    else if (Math.abs(dur - std) < 1e-9) bg = '#4ADE80';
    else bg = '#C084FC';
  }
  sh.getRange(row, cInd, 1, 1).setBackground(bg || null);
}

function repaintAllIndicators_(){
  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);
  var cDur = _findCol(headers, ['durata (ore)','duration(h)','durata']);
  var cInd = _findCol(headers, ['indicator','bulina','indicator bulina']);
  var cAct = _findCol(headers, ['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc = _findCol(headers, ['locație','locatie','location']);
  if (!cDur || !cInd) return;
  _removeIndicatorCF_(sh, cInd);
  var last = Math.max(2, sh.getLastRow());
  for (var r=2; r<=last; r++){
    paintOneIndicatorRow_(sh, r, cDur, cInd, cAct, cLoc);
  }
}

/*********************** PAUSE HELPER ************************/

function _sumPausedMsForInterval_(data, iNm, iAc, iTs, name, tStart, tFinish){
  var evts = [];
  for (var i=0;i<data.length;i++){
    if (!_samePerson(data[i][iNm], name)) continue;
    var a = _normAction(data[i][iAc]);
    if (a !== 'pause' && a !== 'unpause') continue;
    var t = _toDate(data[i][iTs]); if (!t) continue;
    if (t <= tStart || t > tFinish) continue;
    evts.push({t:t, a:a});
  }
  evts.sort(function(x,y){ return x.t - y.t; });

  var pausedMs = 0, openPauseAt = null;
  for (var j=0;j<evts.length;j++){
    var e = evts[j];
    if (e.a === 'pause'){
      if (openPauseAt === null){ openPauseAt = e.t; }
    } else if (e.a === 'unpause'){
      if (openPauseAt !== null){
        pausedMs += (e.t.getTime() - openPauseAt.getTime());
        openPauseAt = null;
      }
    }
  }
  if (openPauseAt !== null){
    pausedMs += (tFinish.getTime() - openPauseAt.getTime());
  }
  return Math.max(0, pausedMs);
}

// === SUMA PAUZELOR DINTR-O ZI (după acțiuni PAUSE/UNPAUSE) ===
function _sumPauseMinutesForDay_(vals, idx, name, dayStart, dayEnd, until){
  name = _norm(name);
  if (!name || !vals || !vals.length) return 0;

  var iNm = idx.iNm, iAc = idx.iAc, iTs = idx.iTs;
  var limit = new Date(Math.min(dayEnd.getTime(), until ? until.getTime() : dayEnd.getTime()));

  var evts = [];
  for (var i=0;i<vals.length;i++){
    if (!_samePerson(vals[i][iNm], name)) continue;
    var t = _toDate(vals[i][iTs]); if (!t) continue;
    if (t < dayStart || t > limit) continue;
    var a = _normAction(vals[i][iAc]);
    if (a !== 'pause' && a !== 'unpause') continue;
    evts.push({t:t, a:a});
  }
  evts.sort(function(x,y){ return x.t - y.t; });

  var totalMs = 0, openPause = null;
  for (var j=0;j<evts.length;j++){
    var e = evts[j];
    if (e.a === 'pause'){
      if (openPause === null) openPause = e.t;
    } else if (e.a === 'unpause'){
      if (openPause !== null){
        totalMs += (e.t.getTime() - openPause.getTime());
        openPause = null;
      }
    }
  }
  if (openPause !== null){
    totalMs += (limit.getTime() - openPause.getTime());
  }
  return Math.max(0, Math.round(totalMs / 60000)); // minute întregi
}


// ==== UTILITARE pentru calcule pe zi RO
function _tzOffsetMillis_(d, tz){
  var z = Utilities.formatDate(d, tz, "Z"); // ex: +0300 / +0200
  var sign = z[0] === '-' ? -1 : 1;
  var hh = parseInt(z.substring(1,3),10) || 0;
  var mm = parseInt(z.substring(3,5),10) || 0;
  return sign * (hh*60 + mm) * 60000;
}
function _dayStartInTZ_(d, tz){
  var ms = d.getTime();
  var off = _tzOffsetMillis_(d, tz);
  var local = ms + off;
  var dayMs = Math.floor(local / 86400000) * 86400000;
  return new Date(dayMs - off);
}
function _ymdInTZ_(d, tz){
  return Utilities.formatDate(d, tz || Session.getScriptTimeZone(), 'yyyy-MM-dd');
}

/**
 * Calculează totalul pauzelor pentru o ZI RO (ziua în care cade `until`) până la momentul `until`.
 * Întoarce: { ok, dayKey, totalMs, curMs, totalMin, curMin }
 */
function _pauseTotalsForDayUntil_(name, until){
  name = _norm(name);
  if (!name) return { ok:true, dayKey:_ymdInTZ_(until, TZ_RO), totalMs:0, curMs:0, totalMin:0, curMin:0 };

  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  if (!sh || sh.getLastRow() < 2) return { ok:true, dayKey:_ymdInTZ_(until, TZ_RO), totalMs:0, curMs:0, totalMin:0, curMin:0 };

  var headers = _getHeaders(sh);
  // Acceptă și f_* din formular
  var cTs  = headers.indexOf('Timestamp') + 1; if(!cTs) cTs = _findCol(headers, ['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cAc  = _findCol(headers,['f_action','action','actiune','acțiune']);
  if(!cTs || !cNm || !cAc) return { ok:true, dayKey:_ymdInTZ_(until, TZ_RO), totalMs:0, curMs:0, totalMin:0, curMin:0 };

  var last = sh.getLastRow();
  var vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();

  var dayStart = _dayStartInTZ_(until, TZ_RO);
  var dayKey = _ymdInTZ_(until, TZ_RO);

  // Strângem toate evenimentele <= until (doar pause/unpause) pentru angajat
  var ev = [];
  for (var i=0;i<vals.length;i++){
    if (!_samePerson(vals[i][cNm-1], name)) continue;
    var a = _normAction(vals[i][cAc-1]); if (a!=='pause' && a!=='unpause') continue;
    var t = _toDate(vals[i][cTs-1]); if (!t) continue;
    if (t > until) continue;
    ev.push({t:t, a:a});
  }
  if (!ev.length) return { ok:true, dayKey:dayKey, totalMs:0, curMs:0, totalMin:0, curMin:0 };

  ev.sort(function(x,y){ return x.t - y.t; });

  // Starea la miezul nopții (în RO): eram în PAUSE?
  var paused = false;
  for (var j=0;j<ev.length;j++){
    if (ev[j].t >= dayStart) break;
    if (ev[j].a === 'pause') paused = true;
    else if (ev[j].a === 'unpause') paused = false;
  }

  var totalMs = 0, curMs = 0;
  var cursor = dayStart;
  var lastPauseOpenAt = paused ? dayStart : null;

  // Rulează prin evenimentele din fereastra [dayStart, until]
  for (var k=0;k<ev.length;k++){
    var e = ev[k];
    if (e.t < dayStart) continue;
    if (e.t > until) break;

    if (paused){
      // adună de la cursor până la acest eveniment
      totalMs += Math.max(0, e.t.getTime() - cursor.getTime());
      // dacă evenimentul este UNPAUSE, închidem segmentul curent
      if (e.a === 'unpause' && lastPauseOpenAt){
        curMs = Math.max(0, e.t.getTime() - lastPauseOpenAt.getTime());
        paused = false;
        lastPauseOpenAt = null;
      }
    } else {
      // dacă vine un PAUSE, deschidem segment
      if (e.a === 'pause'){
        paused = true;
        lastPauseOpenAt = e.t;
      }
    }
    cursor = e.t;
  }

  // Dacă încă suntem în PAUSE la momentul `until`, închide la until
  if (paused){
    totalMs += Math.max(0, until.getTime() - cursor.getTime());
    if (lastPauseOpenAt){
      curMs = Math.max(0, until.getTime() - lastPauseOpenAt.getTime());
    }
  }

  return {
    ok:true,
    dayKey: dayKey,
    totalMs: totalMs,
    curMs: curMs,
    totalMin: Math.round(totalMs/60000),
    curMin:   Math.round(curMs/60000)
  };
}



/*********************** STATISTICI (helperi generici) ************************/
/**
 * Calculează statistici pentru un angajat într-un interval [tStart, tEnd] (inclusiv).
 * Folosește evenimentele din „Responses”: START/PAUSE/UNPAUSE/FINISH + EXTRA_START/EXTRA_FINISH.
 */
function _computeStatsForNameInPeriod_(vals, idx, name, tStart, tEnd){
  name = _norm(name);
  var s = {
    totalHours:0,           // ore net (fără pauze) din START..FINISH
    totalStdHours:0,        // suma normelor per interval (8/8.5 în funcție de activitate)
    totalOvertime:0,        // ore suplimentare (>0 doar când net depășește norma)
    totalPauseHours:0,      // ore pauză (PAUSE..UNPAUSE înăuntrul START..FINISH)
    totalExtraHours:0,      // ore din EXTRA_START..EXTRA_FINISH
    actions:{ start:0, pause:0, unpause:0, finish:0, extra_start:0, extra_finish:0 },
    overStdCount:0,         // număr intervale cu net > normă
    underStdCount:0         // număr intervale cu net < normă
  };
  if (!name || !vals || !vals.length) return s;
  var iNm=idx.iNm, iAc=idx.iAc, iTs=idx.iTs, iAct=idx.iAct, iLoc=idx.iLoc;

  // 1) număr apăsări butoane în interval
  if (iAc >= 0){
    for (var i=0;i<vals.length;i++){
      if (!_samePerson(vals[i][iNm], name)) continue;
      var t1 = _toDate(vals[i][iTs]); if (!t1) continue;
      if (t1 < tStart || t1 > tEnd) continue;
      var a1 = _normAction(vals[i][iAc]);
      if (s.actions.hasOwnProperty(a1)) s.actions[a1]++;
    }
  }

  // 2) parcurge FINISH / EXTRA_FINISH din interval
  for (var r=0;r<vals.length;r++){
    if (!_samePerson(vals[r][iNm], name)) continue;
    var tF = _toDate(vals[r][iTs]); if (!tF) continue;
    if (tF < tStart || tF > tEnd) continue;
    var a2 = _normAction(vals[r][iAc]);

    if (a2 === 'finish'){
      // caută cel mai recent START anterior
      var startTime=null, startIdx=-1;
      for (var j=r-1;j>=0;j--){
        if (!_samePerson(vals[j][iNm], name)) continue;
        var tj=_toDate(vals[j][iTs]); if (!tj || tj > tF) continue;
        var aj=_normAction(vals[j][iAc]);
        if (aj === 'start'){ startTime=tj; startIdx=j; break; }
      }
      if (startTime){
        var pausedMs=_sumPausedMsForInterval_(vals, iNm, iAc, iTs, name, startTime, tF);
        var grossMs=tF.getTime()-startTime.getTime();
        var netH = _round2((grossMs - pausedMs)/36e5);
        var pauseH = _round2(pausedMs/36e5);

        // activitate: întâi rândul FINISH, apoi START, apoi location dacă arată ca activitate
        var act='';
        if (iAct >= 0) act=_norm(vals[r][iAct]);
        if (!act && iAct >= 0 && startIdx >= 0) act=_norm(vals[startIdx][iAct]);
        if (!act && iLoc >= 0){
          var maybe=_norm(vals[r][iLoc]); if (_isActivity(maybe)) act=maybe;
        }
        var std=_stdHoursForActivity(act);
        var ot = Math.max(0, _round2(netH - std));

        s.totalHours += netH;
        s.totalStdHours += std;
        s.totalOvertime += ot;
        s.totalPauseHours += pauseH;

        if (netH > std + 1e-9) s.overStdCount++;
        else if (netH + 1e-9 < std) s.underStdCount++;
      }
    } else if (a2 === 'extra_finish'){
      // caută EXTRA_START anterior
      var xs=null;
      for (var k=r-1;k>=0;k--){
        if (!_samePerson(vals[k][iNm], name)) continue;
        var tk=_toDate(vals[k][iTs]); if (!tk || tk > tF) continue;
        var ak=_normAction(vals[k][iAc]);
        if (ak === 'extra_start'){ xs=tk; break; }
      }
      if (xs){
        var eh = _round2((tF.getTime()-xs.getTime())/36e5);
        s.totalExtraHours += eh;
      }
    }
  }

  // rotunjiri
  s.totalHours      = _round2(s.totalHours);
  s.totalStdHours   = _round2(s.totalStdHours);
  s.totalOvertime   = _round2(s.totalOvertime);
  s.totalPauseHours = _round2(s.totalPauseHours);
  s.totalExtraHours = _round2(s.totalExtraHours);
  return s;
}
function _mergeStats_(A, B){
  var out = {
    totalHours: _round2((A.totalHours||0)+(B.totalHours||0)),
    totalStdHours: _round2((A.totalStdHours||0)+(B.totalStdHours||0)),
    totalOvertime: _round2((A.totalOvertime||0)+(B.totalOvertime||0)),
    totalPauseHours: _round2((A.totalPauseHours||0)+(B.totalPauseHours||0)),
    totalExtraHours: _round2((A.totalExtraHours||0)+(B.totalExtraHours||0)),
    actions:{ start:0, pause:0, unpause:0, finish:0, extra_start:0, extra_finish:0 },
    overStdCount: (A.overStdCount||0)+(B.overStdCount||0),
    underStdCount: (A.underStdCount||0)+(B.underStdCount||0)
  };
  Object.keys(out.actions).forEach(function(k){
    out.actions[k] = (A.actions && A.actions[k]||0) + (B.actions && B.actions[k]||0);
  });
  return out;
}

// === Helper: format diferență de normă în minute, cu semn ===
function _fmtDiffMinutes_(mins){
  mins = Math.round(Number(mins || 0));
  if (!mins) return '0 min';
  var sign = mins < 0 ? '-' : '+';
  var abs = Math.abs(mins);
  var h = Math.floor(abs / 60);
  var m = abs % 60;
  if (h === 0){
    return sign + m + ' min';
  }
  var mStr = (m < 10 ? '0' : '') + m;
  return sign + h + 'h ' + mStr + ' min';
}

// === Helper: detaliu pe O ZI pentru un angajat (net, normă, extra, pauze, start/finish) ===
function _computeDayDetailForNameRange_(vals, idx, name, dayStart, dayEnd){
  var stats = _computeStatsForNameInPeriod_(vals, idx, name, dayStart, dayEnd);

  if (!stats || stats.totalStdHours <= 0){
    return { netH:0, stdH:0, otH:0, exH:0, pauseMin:0, diffMin:0, otAdjH:0, otAdjMin:0, actList:[] };
  }

  var workMin  = Math.round((stats.totalHours || 0) * 60);        // lucru efectiv (net)
  var stdMin   = Math.round((stats.totalStdHours || 0) * 60);     // norma zilei (480 / 510)
  var pauseMin = Math.round((stats.totalPauseHours || 0) * 60);   // pauza totală

  var ALLOWED_PAUSE_MIN = 30;

  // Pauza normată = maxim 30m
  var pauseNormMin = Math.min(pauseMin, ALLOWED_PAUSE_MIN);

  // Pauza extra = peste 30m
  var pauseExtraMin = Math.max(0, pauseMin - ALLOWED_PAUSE_MIN);

  // ✅ Diferență normă: (lucru efectiv + pauza normată) - normă
  // Pauza în plus NU mai penalizează dacă norma e deja atinsă.
  var diffMin = (workMin + pauseNormMin) - stdMin;

  // ✅ Suplimentar ajustat: doar munca efectivă peste "munca necesară"
  // Norma 8h => munca necesară 7h30 (450m)
  // Norma 8h30 => munca necesară 8h00 (480m)
  var workNormMin = Math.max(0, stdMin - ALLOWED_PAUSE_MIN);
  var otAdjMin = Math.max(0, workMin - workNormMin);

  // ✅ (nul) doar când pauza extra e în plus DUPĂ ce norma e atinsă
  var pauseExtraNull = (pauseExtraMin > 0 && diffMin >= 0);



  // activități folosite în zi
  var actList = [];
  for (var i=0;i<vals.length;i++){
    if (vals[i][idx.name] !== name) continue;
    var dt = vals[i][idx.dt];
    if (!(dt instanceof Date)) continue;
    if (dt < dayStart || dt >= dayEnd) continue;
    var act = vals[i][idx.act];
    if (act) actList.push(act);
  }
  var actSet = {};
  actList.forEach(function(a){actSet[a]=true;});
  actList = Object.keys(actSet).sort();

  return {
    netH: stats.totalHours,
    stdH: stats.totalStdHours,
    otH: stats.totalOvertime, // rămâne (vechi), DAR noi folosim otAdjH în rapoarte
    exH: stats.totalExtraHours,

    pauseMin: pauseMin,
    pauseNormMin: pauseNormMin,
    pauseExtraMin: pauseExtraMin,
    pauseExtraNull: pauseExtraNull,

    diffMin: diffMin,

    otAdjMin: otAdjMin,
    otAdjH: _round2(otAdjMin / 60),

    earliestStart: stats.earliestStart,
    latestFinish: stats.latestFinish,
    actList: actList
  };
}


// === NOU: intervale pe zi (START-FINISH, PAUSE-UNPAUSE, EXTRA_START-EXTRA_FINISH) ===
function _collectDayIntervalsForNameRange_(vals, idx, name, dayStart, dayEnd){
  name = _norm(name);

  var out = { work:[], pause:[], extra:[] };
  if (!name || !vals || !vals.length) return out;

  var iNm = idx.iNm, iAc = idx.iAc, iTs = idx.iTs;

  // colectăm evenimentele din zi (doar cele relevante)
  var evts = [];
  for (var i=0; i<vals.length; i++){
    if (!_samePerson(vals[i][iNm], name)) continue;
    var t = _toDate(vals[i][iTs]); if (!t) continue;
    if (t < dayStart || t > dayEnd) continue;

    var a = _normAction(vals[i][iAc]);
    if (a !== 'start' && a !== 'finish' &&
        a !== 'pause' && a !== 'unpause' &&
        a !== 'extra_start' && a !== 'extra_finish') continue;

    evts.push({ t:t, a:a });
  }

  if (!evts.length) return out;
  evts.sort(function(x,y){ return x.t - y.t; });

  // Pairing simplu în zi (dacă există "open" fără pereche -> se închide la dayEnd)
  var openWork = null, openPause = null, openExtra = null;

  for (var j=0; j<evts.length; j++){
    var e = evts[j];

    if (e.a === 'start'){
      if (openWork !== null){
        // START consecutiv -> închidem intervalul precedent la acest START
        out.work.push({ s: openWork, e: e.t });
      }
      openWork = e.t;

    } else if (e.a === 'finish'){
      if (openWork !== null){
        out.work.push({ s: openWork, e: e.t });
        openWork = null;
      }

    } else if (e.a === 'pause'){
      if (openPause !== null){
        // PAUSE dublu -> închidem pauza precedentă la acest PAUSE
        out.pause.push({ s: openPause, e: e.t });
      }
      openPause = e.t;

    } else if (e.a === 'unpause'){
      if (openPause !== null){
        out.pause.push({ s: openPause, e: e.t });
        openPause = null;
      }

    } else if (e.a === 'extra_start'){
      if (openExtra !== null){
        // EXTRA_START dublu -> închidem la acest EXTRA_START
        out.extra.push({ s: openExtra, e: e.t });
      }
      openExtra = e.t;

    } else if (e.a === 'extra_finish'){
      if (openExtra !== null){
        out.extra.push({ s: openExtra, e: e.t });
        openExtra = null;
      }
    }
  }

  // închide orice interval rămas deschis la final de zi
  if (openWork !== null)  out.work.push({ s: openWork,  e: dayEnd });
  if (openPause !== null) out.pause.push({ s: openPause, e: dayEnd });
  if (openExtra !== null) out.extra.push({ s: openExtra, e: dayEnd });

  return out;
}

function _fmtIntervals_(pairs, tz){
  if (!pairs || !pairs.length) return '';
  return pairs.map(function(p){
    var s = Utilities.formatDate(p.s, tz, 'HH:mm');
    var e = Utilities.formatDate(p.e, tz, 'HH:mm');
    return s + ' — ' + e;
  }).join(', ');
}

function _appendStatsTable_(body, stats, title){
  if (title){ body.appendParagraph(title).setHeading(DocumentApp.ParagraphHeading.HEADING2); }
  var table = body.appendTable([['Indicator', 'Valoare']]);
  table.getRow(0).editAsText().setBold(true);

  function row(label,val){
    var tr = table.appendTableRow();
    tr.appendTableCell(String(label));
    tr.appendTableCell(String(val));
  }

  // ore -> "Xh YY min"
  row('Ore totale (net, fără pauze)', _fmtHM_(stats.totalHours));
  row('Ore normă totale',              _fmtHM_(stats.totalStdHours));
  row('Ore suplimentare totale',       _fmtHM_(stats.totalOvertime));
  row('Ore pauze totale',              _fmtHM_(stats.totalPauseHours));
  row('Ore EXTRA totale',              _fmtHM_(stats.totalExtraHours));

  // counts rămân numere
  row('Buton START (x)',               stats.actions.start||0);
  row('Buton PAUSE (x)',               stats.actions.pause||0);
  row('Buton UNPAUSE (x)',             stats.actions.unpause||0);
  row('Buton FINISH (x)',              stats.actions.finish||0);
  row('Buton EXTRA START (x)',         stats.actions.extra_start||0);
  row('Buton EXTRA FINISH (x)',        stats.actions.extra_finish||0);
  row('Depășiri normă (#)',            stats.overStdCount||0);
  row('Sub normă (#)',                 stats.underStdCount||0);

  return table;
}

/*********************** DEPARTAMENTE — CSV PARSE & MAP ************************/

function _detectSep_(text){
  var c = (text.match(/,/g)||[]).length;
  var s = (text.match(/;/g)||[]).length;
  return s > c ? ';' : ',';
}

// parsează CSV și întoarce mapă cu CHEI NORMALIZATE: { normName -> dept original }
function _parseDepartmentsCsv_(text){
  var out = {};
  if (!text) return out;
  if (text.charCodeAt && text.charCodeAt(0) === 0xFEFF) text = text.slice(1); // BOM
  text = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n').trim();
  if (!text) return out;

  var sep = _detectSep_(text);
  var lines = text.split('\n').filter(function(x){return _norm(x).length;});
  if (!lines.length) return out;

  // Detect header sau ghicește coloanele când nu există header
  var hasHeader = false, depIdx = 0, nameIdx = 1;

  (function(){
    var hdrCells = lines[0].split(sep).map(function(s){return s.trim().replace(/^"|"$/g,'');});
    var hdr = hdrCells.map(function(s){return s.toLowerCase();});
    var hasDep = hdr.some(function(h){return /depart|department|dept/.test(h);});
    var hasName = hdr.some(function(h){return /angajat|nume|employee|name/.test(h);});
    if (hasDep || hasName){
      hasHeader = true;
      var di = hdr.findIndex(function(h){return /depart|department|dept/.test(h);});
      var ni = hdr.findIndex(function(h){return /angajat|nume|employee|name/.test(h);});
      if (di >= 0) depIdx = di;
      if (ni >= 0) nameIdx = ni;
    } else {
      // fără header: ghicește care coloană e Departament (după conținut)
      var sampleLines = lines.slice(0, Math.min(5, lines.length));
      var parsed = sampleLines.map(function(L){ return L.split(sep).map(function(s){return s.trim().replace(/^"|"$/g,'');}); });
      var cols = parsed[0].length;
      if (cols >= 2){
        var scores = new Array(cols).fill(0);
        for (var r=0; r<parsed.length; r++){
          for (var c=0; c<cols; c++){
            if (_looksLikeDept_(parsed[r][c])) scores[c]++;
          }
        }
        // col cu scor maxim = Departament; numele = prima coloană diferită
        depIdx = scores.indexOf(Math.max.apply(null, scores));
        nameIdx = depIdx === 0 ? 1 : 0;
      }
    }
  })();

  var start = hasHeader ? 1 : 0;
  for (var i=start;i<lines.length;i++){
    var cells = lines[i].split(sep).map(function(s){return s.trim().replace(/^"|"$/g,'');});
    var dep = _norm(cells[depIdx]);
    var nm  = _norm(cells[nameIdx]);
    if (!nm || !dep) continue;
    out[_normKeyName_(nm)] = dep; // CHEIE NORMALIZATĂ
  }
  return out;
}

function _getDepartmentsCsvUrl_(){
  var p = PropertiesService.getScriptProperties().getProperty('departmentsCsv');
  return _norm(p) || DEPARTMENTS_CSV_URL_FALLBACK;
}

// citește mapa din cache sau fetch; forceFresh=true sare peste cache
function _getDeptMapByName_(forceFresh){
  var cache = CacheService.getScriptCache();
  if (!forceFresh){
    var cached = cache.get('dept_map_by_name_v2');
    if (cached){ try { return JSON.parse(cached); } catch(e){} }
  }
  var url = _getDepartmentsCsvUrl_();
  var map = {};
  try{
    var resp = UrlFetchApp.fetch(url, {muteHttpExceptions:true});
    if (resp && resp.getResponseCode() === 200){
      map = _parseDepartmentsCsv_(resp.getContentText());
    }
  }catch(e){
    Logger.log('Dept CSV fetch error: ' + e);
  }
  try{ cache.put('dept_map_by_name_v2', JSON.stringify(map), 600); }catch(e){}
  return map;
}

// utilitar manual pentru golirea cache-ului
function clearDeptCache(){
  try{ CacheService.getScriptCache().remove('dept_map_by_name_v2'); }catch(e){}
}

// helper generic: departament după nume, strict din departments.csv (cu fallback "productie")
function _getDeptForName_(name){
  name = _norm(name);
  if (!name) return 'productie';
  var key = _normKeyName_(name);
  var map = _getDeptMapByName_(false);
  var dept = _norm(map[key]);
  if (!dept){
    map = _getDeptMapByName_(true);
    dept = _norm(map[key]);
  }
  return dept || 'productie';
}

/********** DEPARTAMENTE — EXTRAGERE DIN EVENT & FOAIE (EVITĂM FALS-FALLBACK) **********/

// returnează departamentul din evenimentul de submit (cheile din form/index.html)
function _getDeptFromEvent_(e){
  try{
    var nv = (e && e.namedValues) ? e.namedValues : {};
    for (var k in nv){
      if (!nv.hasOwnProperty(k)) continue;
      var key = _deaccent(String(k).toLowerCase());
      if (/depart|department|dept/.test(key)){
        var v = nv[k];
        if (Array.isArray(v)) v = v[0];
        v = _norm(v);
        if (v) return v;
      }
    }
  }catch(_){}
  return '';
}

// caută pe rândul curent o coloană de tip departament DIFERITĂ de „Departament” (cea standard a scriptului)
function _getDeptFromSheetRow_(sh, row, headers){
  if (!sh || row < 2 || !headers || !headers.length) return '';
  for (var c = 1; c <= headers.length; c++){
    var headerRaw = String(headers[c-1]).trim();
    var h = _deaccent(headerRaw.toLowerCase());
    // sari peste coloana standard exact "Departament" (creată de script)
    var isStd = /^departament$/i.test(headerRaw);
    if (isStd) continue;
    if (/depart|department|dept/.test(h)){
      var val = _norm(sh.getRange(row, c).getDisplayValue());
      if (val) return val;
    }
  }
  return '';
}

/*********************** HANDLERS FORM/EDIT ************************/

function _ensureDepartmentAndFillRow_(sh, row, headers, name, deptHint){
  // Găsește/creează coloană standard „Departament” și setează valoarea
  var cDept = _findCol(headers, ['departament','department','dept']);
  if (!cDept){
    sh.insertColumnAfter(sh.getLastColumn());
    cDept = sh.getLastColumn();
    sh.getRange(1, cDept).setValue('Departament');
    headers = _getHeaders(sh);
  }

  var cur = _norm(sh.getRange(row, cDept).getDisplayValue());
  if (!cur){
    // 1) dacă a venit din Form (hint), folosește-l
    var dept = _norm(deptHint);

    // 2) altfel încearcă CSV cu cheie NORMALIZATĂ; dacă nu găsește, refetch și mai încearcă încă o dată
    if (!dept){
      var key = _normKeyName_(name);
      var map = _getDeptMapByName_(false);
      dept = _norm(map[key]);
      if (!dept){
        map = _getDeptMapByName_(true); // refresh
        dept = _norm(map[key]);
      }
    }

    // 3) fallback final
    if (!dept) {
      dept = 'productie';
      Logger.log('Fallback departament pentru "' + name + '" -> productie (negăsit în CSV).');
    }

    sh.getRange(row, cDept).setValue(dept);
  }
  return cDept; // în caz că e util mai jos
}

function onFormSubmit(e){
  var sh = e.range.getSheet();
  var headers = _getHeaders(sh);

  var cTs = headers.indexOf('Timestamp') + 1; 
  if (!cTs) cTs = _findCol(headers, ['f_timestamp','timestamp','data','ora']);
  var cAc = _findCol(headers, ['f_action','action','actiune','acțiune']);
  var cNm = _findCol(headers, ['f_name','name','nume','angajat']);

  var cActType = _findCol(headers, ['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc = _findCol(headers, ['locație','locatie','location']);
  if(!cTs || !cAc || !cNm) return;

  var row = e.range.getRow();
  var action = _normAction(sh.getRange(row, cAc).getDisplayValue());
  var name  = _norm(sh.getRange(row, cNm).getDisplayValue());

  // === DEPARTAMENT: citește prioritar din event (form/index.html), altfel din altă coloană non-standard, altfel CSV/fallback
  var deptHint = _getDeptFromEvent_(e);
  if (!deptHint) {
    deptHint = _getDeptFromSheetRow_(sh, row, headers);
  }
  _ensureDepartmentAndFillRow_(sh, row, headers, name, deptHint);
  headers = _getHeaders(sh); // reîmprospătează dacă am inserat coloană

  if(['finish','start','pause','unpause','extra_start','extra_finish'].indexOf(action) === -1) {
    // Totuși, repoarnește indicatorul dacă a fost edit pe alt tip
    var cInd0 = _findCol(headers, ['indicator','bulina','indicator bulina']);
    if (cInd0){ _removeIndicatorCF_(sh, cInd0); paintOneIndicatorRow_(sh, row,
      _findCol(headers,['durata (ore)','duration(h)','durata']),
      cInd0,
      _findCol(headers, ['tip de activitate','activity type','tip activitate','activitate']),
      _findCol(headers, ['locație','locatie','location'])
    );}
    return;
  }

  var cDur = _findCol(headers, ['durata (ore)','duration(h)','durata']);
  if(!cDur){
    sh.insertColumnAfter(headers.length);
    cDur = headers.length + 1;
    sh.getRange(1, cDur).setValue('Durata (ore)');
    sh.getRange(2, cDur, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat('0.00');
    headers = _getHeaders(sh);
  }
  var cInd = _findCol(headers, ['indicator','bulina','indicator bulina']);
  if(!cInd){
    sh.insertColumnAfter(sh.getLastColumn());
    cInd = sh.getLastColumn();
    sh.getRange(1, cInd).setValue('Indicator');
    headers = _getHeaders(sh);
  }
  var cOT = _findCol(headers, ['suplimentar (h)','overtime','suplimentar']);
  if(!cOT){
    sh.insertColumnAfter(sh.getLastColumn());
    cOT = sh.getLastColumn();
    sh.getRange(1, cOT).setValue('Suplimentar (h)');
    sh.getRange(2, cOT, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat('0.00');
    headers = _getHeaders(sh);
  }
  var cEX = _findCol(headers, ['extra (h)','extra']);
  if(!cEX){
    sh.insertColumnAfter(sh.getLastColumn());
    cEX = sh.getLastColumn();
    sh.getRange(1, cEX).setValue('Extra (h)');
    sh.getRange(2, cEX, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat('0.00');
    headers = _getHeaders(sh);
  }

  var cTsIdx = cTs-1, cAcIdx = cAc-1, cNmIdx = cNm-1;
  var tsFinish = _toDate(sh.getRange(row, cTs).getValue());

  if(action === 'finish' || action === 'extra_finish'){
    if(tsFinish){
      var data = sh.getRange(2, 1, Math.max(0, sh.getLastRow()-1), sh.getLastColumn()).getValues();

      var lookFor = (action === 'finish') ? 'start' : 'extra_start';

      var startTime = null;
      for (var i = data.length - 1; i >= 0; i--) {
        var a = _normAction(data[i][cAcIdx]);
        var t = _toDate(data[i][cTsIdx]);
        if (!_samePerson(data[i][cNmIdx], name) || !t || t > tsFinish) continue;
        if (a === lookFor) { startTime = t; break; }
      }

      if(startTime){
        if (action === 'finish'){
          var pausedMs = _sumPausedMsForInterval_(data, cNmIdx, cAcIdx, cTsIdx, name, startTime, tsFinish);
          var gross = tsFinish.getTime() - startTime.getTime();
          var net = Math.max(0, gross - pausedMs);
          var hours = _round2(net/36e5);
          sh.getRange(row, cDur).setNumberFormat('0.00').setValue(hours);
          sh.getRange(row, cInd).setValue('');
        } else {
          var grossE = tsFinish.getTime() - startTime.getTime();
          var hE = _round2(grossE/36e5);
          sh.getRange(row, cEX).setNumberFormat('0.00').setValue(hE);
        }
      } else {
        if (action === 'finish'){ sh.getRange(row, cDur).setValue(''); }
        if (action === 'extra_finish'){ sh.getRange(row, cEX).setValue(''); }
        sh.getRange(row, cInd).setValue('');
      }
    }
  } else {
    sh.getRange(row, cInd).setValue('');
  }

  _removeIndicatorCF_(sh, cInd);
  var cAct = _findCol(headers, ['tip de activitate','activity type','tip activitate','activitate']);
  paintOneIndicatorRow_(sh, row, cDur, cInd, cAct, cLoc);

  // Invalidează cache-ul de stare pentru acest angajat (ca să nu rămânem 60s cu status vechi)
  try{
    var cacheS = CacheService.getScriptCache();
    cacheS.remove('state:' + _normKeyName_(name));
  } catch(_){}

  try { buildDailySummary(); } catch (err) { Logger.log(err); }
  try { buildMonthlyTotals(); } catch (err) { Logger.log(err); }
  try { buildOvertimeSheet(); } catch (err) { Logger.log(err); }
  try { buildExtraSheet(); } catch (err) { Logger.log(err); }
  try { buildTopOvertime(); } catch (err) { Logger.log(err); } // nou: actualizează Top suplimentar
}

function onEdit(e){
  if (!e || !e.range) return;
  var sh = e.range.getSheet();
  var row = e.range.getRow(), col = e.range.getColumn();
  if (row < 2) return;

  var headers = _getHeaders(sh);
  var cDur = _findCol(headers, ['durata (ore)','duration(h)','durata']);
  var cAct = _findCol(headers, ['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc = _findCol(headers, ['locație','locatie','location']);
  var cInd = _findCol(headers, ['indicator','bulina','indicator bulina']);
  if (!cDur || !cInd) return;

  if (col !== cDur && col !== cAct && col !== cLoc) return;

  var rawDur = sh.getRange(row, cDur).getValue();
  var dur = _asHours(rawDur);
  sh.getRange(row, cDur).setNumberFormat('0.00').setValue(dur);
  sh.getRange(row, cInd).setValue('');

  _removeIndicatorCF_(sh, cInd);
  paintOneIndicatorRow_(sh, row, cDur, cInd, cAct, cLoc);
}

/*********************** CONFIG RAPOARTE & DRIVE ************************/

const REPORTS_PARENT_ID = "12iHri0ecXsio1wNNfhn7YP1UMkzunkOZ";

function _getReportsRoot() {
  if (REPORTS_PARENT_ID && REPORTS_PARENT_ID.trim()) {
    try { return DriveApp.getFolderById(REPORTS_PARENT_ID.trim()); }
    catch (e) { Logger.log("Folder ID invalid sau inaccesibil: " + e); }
  }
  return DriveApp.getRootFolder();
}
function _getReportsRoot_() {  // păstrăm aliasul tău existent
  return _getReportsRoot();
}
function _ensureFolder_(parent, name){
  var it = parent.getFoldersByName(name);
  return it.hasNext() ? it.next() : parent.createFolder(name);
}
function _moveFileToFolder_(file, destFolder){
  try { file.moveTo(destFolder); }
  catch (err) {
    try { destFolder.addFile(file); DriveApp.getRootFolder().removeFile(file); }
    catch(e2){ Logger.log('Nu am putut muta fișierul: ' + (e2 && e2.message ? e2.message : e2)); }
  }
}

/*********************** SHEET BUILDERS ************************/

function _ensureSheet_(ss, name, headers) {
  var sh = ss.getSheetByName(name) || ss.insertSheet(name);
  sh.clearContents();
  if (headers && headers.length) {
    sh.getRange(1, 1, 1, headers.length).setValues([headers]);
    sh.getRange(1, 1, 1, headers.length).setFontWeight('bold');
  }
  return sh;
}

function buildDailySummary(){
  var ss = SpreadsheetApp.getActive();
  var formSh = _getResponsesSheet_(ss);
  var headers = _getHeaders(formSh);

  var cTs  = headers.indexOf('Timestamp') + 1;
  if (!cTs) cTs = _findCol(headers, ['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cDur = _findCol(headers,['durata (ore)','duration(h)','durata']);
  var cOT  = _findCol(headers,['suplimentar (h)','overtime','suplimentar']);
  var cEX  = _findCol(headers,['extra (h)','extra']);
  var cLoc = _findCol(headers,['locație','locatie','location','locations','client']);

  // Dacă nu avem coloane de bază, doar creăm structura „Ore zilnice”
  if (!cTs || !cNm || !cDur){
    var sh0 = _ensureSheet_(ss, 'Ore zilnice', ['Nume','Data','Ore','Suplimentar (h)','Extra (h)','Client']);
    sh0.getRange(2,3, Math.max(1, sh0.getMaxRows()-1), 3).setNumberFormat(DUR_FMT);
    sh0.autoResizeColumns(1,6);
    PropertiesService.getScriptProperties().setProperty('daily_details_json', JSON.stringify({}));
    return;
  }

  var last = Math.max(2, formSh.getLastRow());
  if (last < 2) {
    var sh1 = _ensureSheet_(ss, 'Ore zilnice', ['Nume','Data','Ore','Suplimentar (h)','Extra (h)','Client']);
    sh1.getRange(2,3, Math.max(1, sh1.getMaxRows()-1), 3).setNumberFormat(DUR_FMT);
    sh1.autoResizeColumns(1,6);
    PropertiesService.getScriptProperties().setProperty('daily_details_json', JSON.stringify({}));
    return;
  }

  var vals = formSh.getRange(2, 1, last-1, formSh.getLastColumn()).getValues();
  var map = {};
  var tz = TZ_RO;

  for (var i = 0; i < vals.length; i++){
    var ts = _toDate(vals[i][cTs-1]); if (!ts) continue;
    var name = _norm(vals[i][cNm-1]); if (!name) continue;

    var d = new Date(ts); d.setHours(0,0,0,0);
    var dayStr = Utilities.formatDate(d, tz, 'yyyy-MM-dd');
    var key = name + '|' + dayStr;

    if (!map[key]) {
      map[key] = { h:0, ot:0, ex:0, locs:[], hasWork:false };
    }

    var h   = _asHours(vals[i][cDur-1]);
    var ot  = cOT ? _num(vals[i][cOT-1]) : Math.max(0, h - 8);
    var ex  = cEX ? _num(vals[i][cEX-1]) : 0;
    var loc = cLoc ? _norm(vals[i][cLoc-1]) : '';

    if (h > 0 || ex > 0) map[key].hasWork = true;

    if (h > 0){
      map[key].h  += h;
      map[key].ot += (cOT ? ot : Math.max(0, h - 8));
    }
    if (ex > 0){
      map[key].ex += ex;
    }

    if (loc) {
      if (map[key].locs.indexOf(loc) === -1) map[key].locs.push(loc);
    }
  }

  var out = [['Nume','Data','Ore','Suplimentar (h)','Extra (h)','Client']];

  Object.keys(map).sort().forEach(function(k){
    var v = map[k];
    if (!v.hasWork) return;

    var p = k.split('|');
    var clientStr = (v.locs && v.locs.length) ? v.locs.join(', ') : '';

    out.push([
      p[0],
      p[1],
      _hoursToDuration_(_round2(v.h)),     // DURATĂ
      _hoursToDuration_(_round2(v.ot)),    // DURATĂ
      _hoursToDuration_(_round2(v.ex)),    // DURATĂ
      clientStr
    ]);
  });

  var sh = _ensureSheet_(ss, 'Ore zilnice', out[0]);
  if (out.length > 1) {
    sh.getRange(2, 1, out.length-1, out[0].length).setValues(out.slice(1));
  }

  // Format durată pe Ore/Suplimentar/Extra
  sh.getRange(2,3, Math.max(1, sh.getMaxRows()-1), 3).setNumberFormat(DUR_FMT);
  sh.autoResizeColumns(1,6);

  // JSON intern rămâne în ore zecimale (pentru endpoint stats)
  var jsonMap = {};
  Object.keys(map).forEach(function(k){
    var v = map[k];
    if (!v.hasWork) return;
    jsonMap[k] = {
      h:  _round2(v.h),
      ot: _round2(v.ot),
      ex: _round2(v.ex)
    };
  });
  PropertiesService.getScriptProperties().setProperty('daily_details_json', JSON.stringify(jsonMap));
}


function buildMonthlyTotals(){
  var ss = SpreadsheetApp.getActive();
  var daily = ss.getSheetByName('Ore zilnice');
  var t = _ensureSheet_(ss, 'Total lunar', ['Nume','Luna','Total ore','Suplimentar (h)','Extra (h)']);

  // format durată pe coloanele 3..5
  t.getRange(2,3, Math.max(1, t.getMaxRows()-1), 3).setNumberFormat(DUR_FMT);

  if (!daily || daily.getLastRow() < 2) { 
    t.autoResizeColumns(1,5); 
    return; 
  }

  // valori brute (pentru nume + data)
  var vals = daily.getRange(2,1,daily.getLastRow()-1, 5).getValues();
  // valori afișate (pentru durate)
  var disp = daily.getRange(2,1,daily.getLastRow()-1, 5).getDisplayValues();

  var map = {};
  for (var i=0;i<vals.length;i++){
    var n  = _norm(vals[i][0]);
    var ds = vals[i][1];
    if(!n || !ds) continue;

    var d = (Object.prototype.toString.call(ds)==='[object Date]') ? ds : new Date(ds);
    if (isNaN(d)) continue;
    var ym = d.getFullYear()+'-'+('0'+(d.getMonth()+1)).slice(-2);
    var key = n+'|'+ym;

    var hM  = _durationToMinutes_(disp[i][2]); // Ore
    var otM = _durationToMinutes_(disp[i][3]); // Suplimentar
    var exM = _durationToMinutes_(disp[i][4]); // Extra

    if(!map[key]) map[key] = {hM:0, otM:0, exM:0};
    map[key].hM  += hM;
    map[key].otM += otM;
    map[key].exM += exM;
  }

  var out = [['Nume','Luna','Total ore','Suplimentar (h)','Extra (h)']];
  Object.keys(map).sort().forEach(function(k){
    var p=k.split('|'); var v=map[k];
    out.push([
      p[0],
      p[1],
      _minutesToDuration_(v.hM),
      _minutesToDuration_(v.otM),
      _minutesToDuration_(v.exM)
    ]);
  });

  if (out.length > 1) {
    t.getRange(2,1,out.length-1, out[0].length).setValues(out.slice(1));
  }

  t.getRange(2,3, Math.max(1, t.getMaxRows()-1), 3).setNumberFormat(DUR_FMT);
  t.autoResizeColumns(1,5);
}



function buildOvertimeSheet(){
  var ss = SpreadsheetApp.getActive();
  var daily = ss.getSheetByName('Ore zilnice');
  var sh = _ensureSheet_(ss, 'Ore suplimentare', ['Nume','Data','Suplimentar (h)']);

  sh.getRange(2,3, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);

  if (!daily || daily.getLastRow() < 2) { 
    sh.autoResizeColumns(1,3); 
    return; 
  }

  var vals = daily.getRange(2,1,daily.getLastRow()-1, 5).getValues();
  var disp = daily.getRange(2,1,daily.getLastRow()-1, 5).getDisplayValues();

  var out = [['Nume','Data','Suplimentar (h)']];

  for (var i=0;i<vals.length;i++){
    var n  = _norm(vals[i][0]);
    var ds = vals[i][1];
    if (!n || !ds) continue;

    var otM = _durationToMinutes_(disp[i][3]); // text din col. "Suplimentar (h)"
    if (otM > 0){
      out.push([n, ds, _minutesToDuration_(otM)]);
    }
  }

  if (out.length > 1) {
    sh.getRange(2,1,out.length-1, 3).setValues(out.slice(1));
  }

  sh.getRange(2,3, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);
  sh.autoResizeColumns(1,3);
}



function buildExtraSheet(){
  var ss = SpreadsheetApp.getActive();
  var daily = ss.getSheetByName('Ore zilnice');
  var sh = _ensureSheet_(ss, 'Ore extra', ['Nume','Data','Extra (h)']);

  sh.getRange(2,3, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);

  if (!daily || daily.getLastRow() < 2) { 
    sh.autoResizeColumns(1,3); 
    return; 
  }

  var vals = daily.getRange(2,1,daily.getLastRow()-1, 5).getValues();
  var disp = daily.getRange(2,1,daily.getLastRow()-1, 5).getDisplayValues();

  var out = [['Nume','Data','Extra (h)']];

  for (var i=0;i<vals.length;i++){
    var n  = _norm(vals[i][0]);
    var ds = vals[i][1];
    if (!n || !ds) continue;

    var exM = _durationToMinutes_(disp[i][4]); // text din col. "Extra (h)"
    if (exM > 0){
      out.push([n, ds, _minutesToDuration_(exM)]);
    }
  }

  if (out.length > 1) {
    sh.getRange(2,1,out.length-1, 3).setValues(out.slice(1));
  }

  sh.getRange(2,3, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);
  sh.autoResizeColumns(1,3);
}



/**
 * Top suplimentar / extra pe lună (Top 10)
 * Creează foaia "Top suplimentar"
 */
function buildTopOvertime(){
  var ss = SpreadsheetApp.getActive();
  var daily = ss.getSheetByName('Ore zilnice');
  var header = ['Luna','Tip','Pozitie','Nume','Ore (h)'];
  var sh = _ensureSheet_(ss, 'Top suplimentar', header);

  sh.getRange(2,5, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);

  if (!daily || daily.getLastRow() < 2){
    sh.autoResizeColumns(1,5);
    return;
  }

  var vals = daily.getRange(2,1,daily.getLastRow()-1, 5).getValues();
  var disp = daily.getRange(2,1,daily.getLastRow()-1, 5).getDisplayValues();
  var tz = TZ_RO;

  var perMonth = {}; // ym -> { byEmp: {name:{supM,exM}} }

  for (var i=0;i<vals.length;i++){
    var name = _norm(vals[i][0]);
    var ds   = vals[i][1];
    if (!name || !ds) continue;

    var d = (Object.prototype.toString.call(ds)==='[object Date]') ? ds : new Date(ds);
    if (isNaN(d)) continue;

    var ym = Utilities.formatDate(d, tz, 'yyyy-MM');

    var supM = _durationToMinutes_(disp[i][3]); // text suplimentar
    var exM  = _durationToMinutes_(disp[i][4]); // text extra

    if (!perMonth[ym]) perMonth[ym] = { byEmp:{} };
    if (!perMonth[ym].byEmp[name]) perMonth[ym].byEmp[name] = { supM:0, exM:0 };

    if (supM > 0) perMonth[ym].byEmp[name].supM += supM;
    if (exM  > 0) perMonth[ym].byEmp[name].exM  += exM;
  }

  var out = [header];
  var months = Object.keys(perMonth).sort();

  for (var mIdx=0; mIdx<months.length; mIdx++){
    var ym = months[mIdx];
    var bucket = perMonth[ym];

    var list = [];
    for (var n in bucket.byEmp){
      if (!bucket.byEmp.hasOwnProperty(n)) continue;
      list.push({ name:n, supM:bucket.byEmp[n].supM, exM:bucket.byEmp[n].exM });
    }

    var topSup = list.slice().filter(function(x){ return x.supM>0; })
      .sort(function(a,b){ return b.supM - a.supM; })
      .slice(0,10);

    for (var i1=0;i1<topSup.length;i1++){
      out.push([ym, 'Suplimentar', i1+1, topSup[i1].name, _minutesToDuration_(topSup[i1].supM)]);
    }

    var topEx = list.slice().filter(function(x){ return x.exM>0; })
      .sort(function(a,b){ return b.exM - a.exM; })
      .slice(0,10);

    for (var i2=0;i2<topEx.length;i2++){
      out.push([ym, 'Extra', i2+1, topEx[i2].name, _minutesToDuration_(topEx[i2].exM)]);
    }
  }

  if (out.length > 1){
    sh.getRange(2,1,out.length-1, out[0].length).setValues(out.slice(1));
  }

  sh.getRange(2,5, Math.max(1, sh.getMaxRows()-1), 1).setNumberFormat(DUR_FMT);
  sh.autoResizeColumns(1,5);
}




function rebuildAllReports(){
  buildDailySummary();
  buildMonthlyTotals();
  buildOvertimeSheet();
  buildExtraSheet();
  buildTopOvertime(); // nou
}

/*********************** PDF RAPOARTE ************************/

// ===== FIX 2: dailyReports (tolerant + fallback pe AZI dacă IERI e gol) =====
function dailyReports(){
  var ss = SpreadsheetApp.getActive();
  var formSh = _getResponsesSheet_(ss);
  var headers = _getHeaders(formSh);

  var cTs=_findCol(headers,['f_timestamp','timestamp','data','ora']); if(!cTs) cTs = headers.indexOf('Timestamp')+1;
  var cNm=_findCol(headers,['f_name','name','nume','angajat']);
  var cDur=_findCol(headers,['durata (ore)','duration(h)','durata']);
  var cOT =_findCol(headers,['suplimentar (h)','overtime','suplimentar']);
  var cEX=_findCol(headers,['extra (h)','extra']);
  var cAct=_findCol(headers,['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc=_findCol(headers,['locație','locatie','location']);
  var cAc = _findCol(headers,['f_action','action','actiune','acțiune']); // poate lipsi

  // Coloane minime
  if(!cTs||!cNm||!cDur) return [];

  var tz = TZ_RO;
  var now = new Date();
  var created = [];

  function rangeFor(d){
    var s=new Date(d); s.setHours(0,0,0,0);
    var e=new Date(d); e.setHours(23,59,59,999);
    return {start:s,end:e,dayStr:Utilities.formatDate(s, tz, 'yyyy-MM-dd')};
  }

  // IERI & fallback AZI
  var rYesterday = rangeFor(new Date(now.getFullYear(), now.getMonth(), now.getDate()-1));
  var rToday     = rangeFor(now);

  var vals=formSh.getRange(
    2,1, Math.max(0,formSh.getLastRow()-1), formSh.getLastColumn()
  ).getValues();

  function hasData(rg){
    for (var i=0;i<vals.length;i++){
      var ts=_toDate(vals[i][cTs-1]); if(!ts || ts<rg.start || ts>rg.end) continue;
      var h=_asHours(vals[i][cDur-1]);
      var ex = cEX? _num(vals[i][cEX-1]) : 0;
      if (h>0 || ex>0) return true;
    }
    return false;
  }

  var rg = hasData(rYesterday) ? rYesterday : (hasData(rToday) ? rToday : null);
  if (!rg) return []; // nimic de raportat

  var byEmp = {};
  for (var i=0;i<vals.length;i++){
    var ts=_toDate(vals[i][cTs-1]); if(!ts || ts<rg.start || ts>rg.end) continue;
    var n=_norm(vals[i][cNm-1]); if(!n) continue;

    var h=_asHours(vals[i][cDur-1]);
    var ot=cOT? _num(vals[i][cOT-1]) : Math.max(0,h-8);
    var ex=cEX? _num(vals[i][cEX-1]) : 0;
    var act=cAct? _norm(vals[i][cAct-1]) : '';
    var loc=cLoc? _norm(vals[i][cLoc-1]) : '';

    if (!byEmp[n]) byEmp[n] = { totalH:0, totalOT:0, totalEX:0, rows:[], extra:[] };
    if (h>0){
      byEmp[n].totalH += h;
      byEmp[n].totalOT += ot;
      byEmp[n].rows.push({
        time: Utilities.formatDate(ts, tz, 'HH:mm'),
        act: act,
        loc: loc,
        h: _round2(h),
        ot: _round2(ot)
      });
    }
    if (ex>0){
      byEmp[n].totalEX += ex;
      byEmp[n].extra.push({
        time: Utilities.formatDate(ts, tz, 'HH:mm'),
        act: act,
        loc: loc,
        h: _round2(ex)
      });
    }
  }

  var root = _getReportsRoot_();
  var baseDaily = _ensureFolder_(root, 'Pontaj - Rapoarte Zilnice');
  var year = Utilities.formatDate(rg.start, tz, 'yyyy');
  var month = Utilities.formatDate(rg.start, tz, 'yyyy-MM');

  // index pentru STATISTICI (doar dacă există Action)
  var idx = null, canStats = !!cAc;
  if (canStats){
    idx = { iNm:cNm-1, iAc:cAc-1, iTs:cTs-1, iAct:(cAct?cAct-1:-1), iLoc:(cLoc?cLoc-1:-1) };
  }

  var empNames = Object.keys(byEmp);
  for (var e=0; e<empNames.length; e++){
    var name = empNames[e];
    var info = byEmp[name];

    var dept = _getDeptForName_(name);
    var fDept = _ensureFolder_(baseDaily, dept);
    var fYear = _ensureFolder_(fDept, year);
    var fMonth = _ensureFolder_(fYear, month);
    var fDay = _ensureFolder_(fMonth, rg.dayStr);

    var doc = DocumentApp.create('Raport Zilnic - ' + name + ' - ' + rg.dayStr);
    var b = doc.getBody();
    b.appendParagraph('Raport Zilnic Pontaj').setHeading(DocumentApp.ParagraphHeading.HEADING1);
    b.appendParagraph('Angajat: ' + name).setHeading(DocumentApp.ParagraphHeading.HEADING2);
    b.appendParagraph('Data: ' + rg.dayStr);
    b.appendParagraph(' ');

    if (info.rows.length){
      var table = b.appendTable([['Ora', 'Tip activitate', 'Locație', 'Ore', 'Suplimentar (h)']]);
      table.getRow(0).editAsText().setBold(true);
      info.rows.sort(function(a,b){ return a.time.localeCompare(b.time); });
      info.rows.forEach(function(rw){
        var tr = table.appendTableRow();
        tr.appendTableCell(String(rw.time));
        tr.appendTableCell(String(rw.act || ''));
        tr.appendTableCell(String(rw.loc || ''));
        tr.appendTableCell(_fmtHM_(rw.h));
        tr.appendTableCell(_fmtHM_(rw.ot));
      });
      b.appendParagraph('Total ore: ' + _fmtHM_(info.totalH)).setBold(true);
      b.appendParagraph('Suplimentar total: ' + _fmtHM_(info.totalOT)).setBold(true);
      b.appendParagraph(' ');
    }

    if (info.extra.length){
      b.appendParagraph('Ore EXTRA').setHeading(DocumentApp.ParagraphHeading.HEADING2);
      var tableE = b.appendTable([['Ora', 'Tip activitate', 'Locație', 'Extra (h)']]);
      tableE.getRow(0).editAsText().setBold(true);
      info.extra.sort(function(a,b){ return a.time.localeCompare(b.time); });
      info.extra.forEach(function(rw){
        var tr = tableE.appendTableRow();
        tr.appendTableCell(String(rw.time));
        tr.appendTableCell(String(rw.act || ''));
        tr.appendTableCell(String(rw.loc || ''));
        tr.appendTableCell(_fmtHM_(rw.h));
      });
      b.appendParagraph('Total EXTRA: ' + _round2(info.totalEX) + ' h').setBold(true);
      b.appendParagraph(' ');
    }

    if (canStats){
      var stats = _computeStatsForNameInPeriod_(vals, idx, name, rg.start, rg.end);
      _appendStatsTable_(b, stats, 'Statistici (zi)');
    }

    doc.saveAndClose(); Utilities.sleep(400);
    var file = DriveApp.getFileById(doc.getId());
    _moveFileToFolder_(file, fDay);
    var pdf = file.getAs('application/pdf');
    var pdfName = 'Raport_Zilnic_' + name + '_' + rg.dayStr + '.pdf';
    var pdfFile = fDay.createFile(pdf).setName(pdfName);

    created.push({
      kind: 'daily',
      date: rg.dayStr,
      employee: name,
      dept: dept,
      folderUrl: fDay.getUrl(),
      fileUrl: pdfFile.getUrl(),
      fileName: pdfFile.getName(),
      fileId: pdfFile.getId()
    });
  }

  return created;
}


function weeklyReports(){
  var ss = SpreadsheetApp.getActive();
  var formSh = _getResponsesSheet_(ss);
  var headers = _getHeaders(formSh);
  var cTs = _findCol(headers,['f_timestamp','timestamp','data','ora']); if(!cTs) cTs = headers.indexOf('Timestamp')+1;
  var cNm = _findCol(headers,['f_name','name','nume','angajat']);
  var cDur = _findCol(headers,['durata (ore)','duration(h)','durata']);
  var cOT = _findCol(headers,['suplimentar (h)','overtime','suplimentar']);
  var cEX = _findCol(headers,['extra (h)','extra']);
  var cAc = _findCol(headers,['f_action','action','actiune','acțiune']);
  var cAct = _findCol(headers,['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc = _findCol(headers,['locație','locatie','location']);
  if(!cTs||!cNm||!cDur||!cAc) return [];

  var tz = TZ_RO;

  // calculăm săptămâna precedentă (Luni–Duminică)
  var now = new Date();
  var day = now.getDay();
  var todayIs = (day+6)%7; // 0 = Luni
  var start = new Date(now);
  start.setDate(now.getDate()-todayIs-7);
  start.setHours(0,0,0,0);
  var end = new Date(start);
  end.setDate(start.getDate()+6);
  end.setHours(23,59,59,999);

  var vals = formSh.getRange(
    2,1, Math.max(0,formSh.getLastRow()-1), formSh.getLastColumn()
  ).getValues();

  // metadate pe cele 7 zile din săptămână (nume, data, interval)
  var dayNames = ['Luni','Marti','Miercuri','Joi','Vineri','Sambata','Duminica'];
  var daysMeta = [];
  for (var d = 0; d < 7; d++){
    var ds = new Date(start);
    ds.setDate(start.getDate() + d);
    ds.setHours(0,0,0,0);
    var de = new Date(ds);
    de.setHours(23,59,59,999);
    var key = Utilities.formatDate(ds, tz, 'yyyy-MM-dd');
    daysMeta.push({ name: dayNames[d], start: ds, end: de, key: key });
  }

  // agregare: name -> days[yyyy-mm-dd] -> {h, ot, ex, clients[]}
  var perEmp = {};
  for (var i = 0; i < vals.length; i++){
    var ts = _toDate(vals[i][cTs-1]);
    var n  = _norm(vals[i][cNm-1]);
    if (!ts || !n) continue;
    if (ts < start || ts > end) continue;

    var dayKey = _ymdInTZ_(ts, tz);
    var dayMeta = null;
    for (var dm = 0; dm < daysMeta.length; dm++){
      if (daysMeta[dm].key === dayKey){
        dayMeta = daysMeta[dm];
        break;
      }
    }
    if (!dayMeta) continue;

    var h  = _asHours(vals[i][cDur-1]);
    var ot = cOT ? _num(vals[i][cOT-1]) : Math.max(0, h - 8);
    var ex = cEX ? _num(vals[i][cEX-1]) : 0;
    var locVal = cLoc ? _norm(vals[i][cLoc-1]) : '';

    if (!perEmp[n]){
      perEmp[n] = { days:{}, total:0, totalOT:0, totalEX:0 };
    }
    var dayBucket = perEmp[n].days[dayKey];
    if (!dayBucket){
      dayBucket = { h:0, ot:0, ex:0, clients:[] };
      perEmp[n].days[dayKey] = dayBucket;
    }

    if (h > 0){
      dayBucket.h  += h;
      dayBucket.ot += ot;
      perEmp[n].total   += h;
      perEmp[n].totalOT += ot;
    }
    if (ex > 0){
      dayBucket.ex += ex;
      perEmp[n].totalEX += ex;
    }

    if (locVal){
      if (dayBucket.clients.indexOf(locVal) === -1){
        dayBucket.clients.push(locVal);
      }
    }
  }

  var root = _getReportsRoot_();
  var baseWeekly = _ensureFolder_(root, 'Pontaj - Rapoarte Saptamanale');
  var yearStr = Utilities.formatDate(start, tz,'yyyy');
  var weekLabel = Utilities.formatDate(start, tz,'YYYY-ww');
  var created = [];

  var idx = { iNm:cNm-1, iAc:cAc-1, iTs:cTs-1, iAct:(cAct?cAct-1:-1), iLoc:(cLoc?cLoc-1:-1) };

  Object.keys(perEmp).forEach(function(name){
    var info = perEmp[name];

    var dept = _getDeptForName_(name);
    var fDept = _ensureFolder_(baseWeekly, dept);
    var fYear = _ensureFolder_(fDept, yearStr);
    var fWeek = _ensureFolder_(fYear, weekLabel);

    var doc = DocumentApp.create('Raport ' + name + ' ' + Utilities.formatDate(start, tz,'yyyy-MM-dd'));
    var b = doc.getBody();
    b.appendParagraph('Raport săptămânal pontaj').setHeading(DocumentApp.ParagraphHeading.HEADING1);
    b.appendParagraph('Angajat: ' + name).setHeading(DocumentApp.ParagraphHeading.HEADING2);
    b.appendParagraph('Interval: ' + Utilities.formatDate(start, tz,'yyyy-MM-dd') +
                      ' — ' + Utilities.formatDate(end, tz,'yyyy-MM-dd'));
    b.appendParagraph(' ');

  var tableHeader = [
  'Zi',
  'Data',
  'Ore',
  'Suplimentar (h)',
  'Extra (h)',
  'Client',
  'Diferență normă',
  'Start/Finish',
  'Intervale pauză (PAUSE–UNPAUSE)',
  'Intervale EXTRA (EXTRA_START–EXTRA_FINISH)',
  'Pauză totală'
];

    var table = b.appendTable([tableHeader]);
    table.getRow(0).editAsText().setBold(true);

    var negTotalMin = 0;

    for (var d = 0; d < daysMeta.length; d++){
      var dm = daysMeta[d];
      var dayKey = dm.key;
      var dayName = dm.name;
      var bucket = info.days[dayKey] || { h:0, ot:0, ex:0, clients:[] };

      // detaliu pe zi (net, normă, pauze, start/finish)
      var det = _computeDayDetailForNameRange_(vals, idx, name, dm.start, dm.end);

      var oreStr = _fmtHM_(bucket.h  || 0);
      var otStr  = _fmtHM_((det && typeof det.otAdjH === "number") ? det.otAdjH : (bucket.ot || 0));
      var exStr  = _fmtHM_(bucket.ex || 0);
      var clientStr = bucket.clients && bucket.clients.length ? bucket.clients.join(', ') : '';

      var diffStr = '';
      if (det && det.stdH > 0){
        diffStr = _fmtDiffMinutes_(det.diffMin || 0);
        if ((det.diffMin || 0) < 0){
          negTotalMin += det.diffMin;
        }
      }

var pauseStr = '';
if (det && det.pauseMin > 0){
  pauseStr = _fmtPauseDetail_(
    det.pauseMin,
    det.pauseNormMin || 0,
    det.pauseExtraMin || 0,
    !!det.pauseExtraNull
  );
}
// intervale multiple (cu virgula)
var intervals = _collectDayIntervalsForNameRange_(vals, idx, name, dm.start, dm.end);

var startFinishStr = _fmtIntervals_(intervals.work, tz);     // START–FINISH multiple
var pauseIntervalsStr = _fmtIntervals_(intervals.pause, tz); // PAUSE–UNPAUSE multiple
var extraIntervalsStr = _fmtIntervals_(intervals.extra, tz); // EXTRA_START–EXTRA_FINISH multiple

var tr = table.appendTableRow();
tr.appendTableCell(dayName);
tr.appendTableCell(dayKey);
tr.appendTableCell(oreStr);
tr.appendTableCell(otStr);
tr.appendTableCell(exStr);
tr.appendTableCell(clientStr);
tr.appendTableCell(diffStr);
tr.appendTableCell(startFinishStr);
tr.appendTableCell(pauseIntervalsStr);
tr.appendTableCell(extraIntervalsStr);
tr.appendTableCell(pauseStr); // Pauză totală (rămâne ca înainte)

    }

    // rând separat cu suma minusurilor pe toată săptămâna
    if (negTotalMin < 0){
      var totalRow = table.appendTableRow();
var cells = [
  'TOTAL minus normă', '', '', '', '', '',
  _fmtDiffMinutes_(negTotalMin),
  '', '', '', ''
];
cells.forEach(function(v){
  totalRow.appendTableCell(String(v));
});
totalRow.getCell(0).editAsText().setBold(true);

    }

    b.appendParagraph('Total: ' + _fmtHM_(info.total)).setBold(true);
    b.appendParagraph('Suplimentar total: ' + _fmtHM_(info.totalOT)).setBold(true);
    b.appendParagraph('Total EXTRA: ' + _fmtHM_(info.totalEX)).setBold(true);
    b.appendParagraph(' ');

    var stats = _computeStatsForNameInPeriod_(vals, idx, name, start, end);
    _appendStatsTable_(b, stats, 'Statistici (săptămână)');

    doc.saveAndClose(); Utilities.sleep(500);

    var file = DriveApp.getFileById(doc.getId());
    _moveFileToFolder_(file, fWeek);
    var blob = file.getAs('application/pdf');
    var pdfName = 'Raport_' + name + '_' + Utilities.formatDate(start, tz,'yyyy-MM-dd') + '.pdf';
    var pdfFile = fWeek.createFile(blob).setName(pdfName);

    created.push({
      kind: 'weekly',
      weekLabel: weekLabel,
      rangeStart: Utilities.formatDate(start, tz,'yyyy-MM-dd'),
      rangeEnd: Utilities.formatDate(end, tz,'yyyy-MM-dd'),
      employee: name,
      dept: dept,
      folderUrl: fWeek.getUrl(),
      fileUrl: pdfFile.getUrl(),
      fileName: pdfFile.getName(),
      fileId: pdfFile.getId()
    });
  });

  return created;
}

// === HELPERE NOI PENTRU RAPOARTE LUNARE CU DETALIU PE ZILE ===

// verifică dacă o dată aparține unei luni YYYY-MM
function _isInYearMonth_(dateObj, ym, tz) {
  if (!dateObj || Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj)) {
    return false;
  }
  var y  = dateObj.getFullYear();
  var m  = dateObj.getMonth() + 1;
  var ymStr = y + '-' + ('0' + m).slice(-2);
  return ymStr === ym;
}

// construiește o mapă: dailyMap[name][YYYY-MM-DD] = { oreH, otH, exH, client }
function _buildDailyMapForMonth_(ym, tz) {
  var ss = SpreadsheetApp.getActive();
  var daily = ss.getSheetByName('Ore zilnice');
  var result = {}; 
  // result[name] = { 'YYYY-MM-DD': { oreH, otH, exH, client } }

  if (!daily || daily.getLastRow() < 2) {
    return result;
  }

  var headers = _getHeaders(daily);
  var cNm  = _findCol(headers, ['nume','name','angajat']);
  var cDate= _findCol(headers, ['data','date']);
  var cOre = _findCol(headers, ['ore']);
  var cOT  = _findCol(headers, ['suplimentar (h)','overtime','suplimentar']);
  var cEX  = _findCol(headers, ['extra (h)','extra']);
  var cCli = _findCol(headers, ['client','locație','locatie','location']);

  if (!cNm || !cDate) return result;

  var last = daily.getLastRow();
  var vals = daily.getRange(2,1,last-1, daily.getLastColumn()).getValues();
  var disp = daily.getRange(2,1,last-1, daily.getLastColumn()).getDisplayValues();

  for (var i=0;i<vals.length;i++){
    var name = _norm(vals[i][cNm-1]); if (!name) continue;
    var ds   = vals[i][cDate-1]; if (!ds) continue;

    var d = (Object.prototype.toString.call(ds)==='[object Date]') ? ds : new Date(ds);
    if (isNaN(d) || !_isInYearMonth_(d, ym, tz)) continue;

    var dayKey = Utilities.formatDate(d, tz, 'yyyy-MM-dd');

    var oreM = cOre ? _durationToMinutes_(disp[i][cOre-1]) : 0;
    var otM  = cOT  ? _durationToMinutes_(disp[i][cOT-1])  : 0;
    var exM  = cEX  ? _durationToMinutes_(disp[i][cEX-1])  : 0;
    var cli  = cCli ? _norm(disp[i][cCli-1]) : '';

    if (!result[name]) result[name] = {};
    result[name][dayKey] = {
      oreH: _round2(oreM / 60),
      otH:  _round2(otM  / 60),
      exH:  _round2(exM  / 60),
      client: cli
    };
  }

  return result;
}


/**
 * Rapoarte lunare (PDF) pe luna precedentă, grupate pe departamente
 * + Statistici extinse (ore normă / pauză / acțiuni / depășiri / sub-normă)
 * Sursă: foaia "Total lunar" (Nume, Luna=YYYY-MM sau Date, Total ore, Suplimentar (h), Extra (h)) + evenimente din Responses
 */
/**
 * Rapoarte lunare (PDF) pe luna precedentă, grupate pe departamente
 * + Statistici extinse (ore normă / pauză / acțiuni / depășiri / sub-normă)
 * Sursă: foaia "Total lunar" (Nume, Luna=YYYY-MM sau Date, Total ore, Suplimentar (h), Extra (h)) + evenimente din Responses
 * EXTINS: include și detalii pe zile din "Ore zilnice"
 */
/**
 * NUCLEU RAPORT LUNAR pentru o lună dată: targetYM = "YYYY-MM"
 * Folosit atât de monthlyReports() (luna precedentă),
 * cât și de monthlyReportsLatest() (ultima lună existentă în "Total lunar").
 */
/**
 * NUCLEU RAPORT LUNAR pentru o lună dată: targetYM = "YYYY-MM"
 * Folosit atât de monthlyReports() (luna precedentă),
 * cât și de monthlyReportsLatest() (ultima lună existentă în "Total lunar").
 * EXTINS: include și DETALIU PE ZILE din "Ore zilnice".
 */
function _monthlyReportsCore_(targetYM){
  if (!targetYM || !/^\d{4}-\d{2}$/.test(targetYM)) {
    Logger.log('monthlyReportsCore: targetYM invalid: ' + targetYM);
    return [];
  }

  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName('Total lunar');
  if (!sh || sh.getLastRow() < 2) return [];

  var headers = _getHeaders(sh);
  var cNm    = _findCol(headers, ['nume','name','angajat']);
  var cMonth = _findCol(headers, ['luna','month']);
  var cTot   = _findCol(headers, ['total ore','total_ore','ore']);
  var cOT    = _findCol(headers, ['suplimentar (h)','overtime','suplimentar']);
  var cEX    = _findCol(headers, ['extra (h)','extra']);

  if (!cNm || !cMonth || !cTot) return [];

  var tz = TZ_RO;

  var parts = targetYM.split('-');
  var year  = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10);
  if (isNaN(year) || isNaN(month)) {
    Logger.log('monthlyReportsCore: nu pot parsa targetYM=' + targetYM);
    return [];
  }
  var mIndex = month - 1; // 0–11

  var last = sh.getLastRow();
  var vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();

  function normYM(cell){
    if (Object.prototype.toString.call(cell) === '[object Date]'){
      return Utilities.formatDate(cell, tz, 'yyyy-MM');
    }
    return _norm(cell);
  }

  var perEmp = {}; // name -> { tot, ot, ex, ym }
  for (var i=0;i<vals.length;i++){
    var name = _norm(vals[i][cNm-1]); if (!name) continue;
    var ym   = normYM(vals[i][cMonth-1]); if (!ym) continue;
    if (ym !== targetYM) continue;  // <-- doar luna cerută

    var tot = cTot ? _durationToHours_(vals[i][cTot-1]) : 0;
    var ot  = cOT  ? _durationToHours_(vals[i][cOT-1])  : 0;
    var ex  = cEX  ? _durationToHours_(vals[i][cEX-1])  : 0;

    perEmp[name] = { tot:_round2(tot), ot:_round2(ot), ex:_round2(ex), ym:ym };
  }

  // Dacă nu există niciun rând în "Total lunar" pentru targetYM, ieșim
  if (!Object.keys(perEmp).length){
    Logger.log('monthlyReportsCore: nu există date în "Total lunar" pentru ' + targetYM);
    return [];
  }

  // === 1) STATISTICI EXTINSE FOLOSIND "Responses" ===
  var formSh = _getResponsesSheet_(ss);
  var rh = _getHeaders(formSh);
  var rcTs=_findCol(rh,['f_timestamp','timestamp','data','ora']); if(!rcTs) rcTs = rh.indexOf('Timestamp')+1;
  var rcNm=_findCol(rh,['f_name','name','nume','angajat']);
  var rcAc=_findCol(rh,['f_action','action','actiune','acțiune']);
  var rcAct=_findCol(rh,['tip de activitate','activity type','tip activitate','activitate']);
  var rcLoc=_findCol(rh,['locație','locatie','location']);
  var rVals = formSh.getRange(
    2,1, Math.max(0,formSh.getLastRow()-1), formSh.getLastColumn()
  ).getValues();
  var idx = { iNm:rcNm-1, iAc:rcAc-1, iTs:rcTs-1, iAct:(rcAct?rcAct-1:-1), iLoc:(rcLoc?rcLoc-1:-1) };

  // Interval pe toată luna (chiar dacă nu e completă, se vor lua doar zilele pontate)
  var monthStart = new Date(year, mIndex, 1);      monthStart.setHours(0,0,0,0);
  var monthEnd   = new Date(year, mIndex+1, 0);    monthEnd.setHours(23,59,59,999);

  // === 2) HARTA PE ZILE DIN "Ore zilnice" (DETALIU PE ZILE) ===
  // result[name][YYYY-MM-DD] = { oreH, otH, exH, client }
  var dailyMap = _buildDailyMapForMonth_(targetYM, tz);

  var root = _getReportsRoot_();
  var baseMonthly = _ensureFolder_(root, 'Pontaj - Rapoarte Lunare');
  var created = [];


// 1) PDF-uri per angajat (doar dacă există date în Total lunar pentru targetYM)
  // 1) PDF-uri per angajat (doar dacă există date în Total lunar pentru targetYM)
  Object.keys(perEmp).forEach(function(name){
    var info = perEmp[name];
    var ym   = info.ym;
    var y    = ym.split('-')[0];

    var dept   = _getDeptForName_(name);
    var fDept  = _ensureFolder_(baseMonthly, dept);
    var fYear  = _ensureFolder_(fDept, y);
    var fMonth = _ensureFolder_(fYear, ym);

    // --- Pregătim detaliile pe zile pentru acest angajat ---
    var empDaily = dailyMap[name] || null;
    var dayKeys = [];
    var dayComputed = {}; // dayKey -> { dInfo, det }
    var negTotalMin = 0;  // sumă diferențe normă în minus (minute, cu semn negativ)
    var totalDiffMin = 0; // sumă totală diferență normă (plus + minus, minute, cu semn)

    if (empDaily && Object.keys(empDaily).length){
      dayKeys = Object.keys(empDaily).sort(); // 2025-01-01, 2025-01-02, ...

      dayKeys.forEach(function(dayKey){
        var dInfo = empDaily[dayKey] || {};

        // intervalul zilei în RO
        var partsDay = dayKey.split('-');
        var baseD = new Date(Number(partsDay[0]), Number(partsDay[1]) - 1, Number(partsDay[2]));
        var dayStart = _dayStartInTZ_(baseD, tz);
        var dayEnd = new Date(dayStart.getTime() + 86400000 - 1); // până la sfârșitul zilei

        // detaliu pe zi: net, normă, pauze, start/finish
        var det = _computeDayDetailForNameRange_(rVals, idx, name, dayStart, dayEnd);
        var intervals = _collectDayIntervalsForNameRange_(rVals, idx, name, dayStart, dayEnd);

        dayComputed[dayKey] = { dInfo: dInfo, det: det, intervals: intervals };


        if (det && det.stdH > 0){
          var dMin = det.diffMin || 0;  // diferență normă pe zi (minute, cu semn)
          totalDiffMin += dMin;
          if (dMin < 0){
            negTotalMin += dMin;       // doar zilele sub normă
          }
        }
      });
    }

    // --- Construim documentul ---
    var doc = DocumentApp.create('Raport Lunar - ' + name + ' - ' + ym);
    var b = doc.getBody();
    b.appendParagraph('Raport Lunar Pontaj').setHeading(DocumentApp.ParagraphHeading.HEADING1);
    b.appendParagraph('Angajat: ' + name).setHeading(DocumentApp.ParagraphHeading.HEADING2);
    b.appendParagraph('Luna: ' + ym);
    b.appendParagraph(' ');

    // --- Statistici extinse pe lună (net, normă, pauze, extra etc.) ---
    var stats = _computeStatsForNameInPeriod_(rVals, idx, name, monthStart, monthEnd);
    var statsTable = _appendStatsTable_(b, stats, 'Statistici (lună)');

    // Rând nou: Total minus normă (suma tuturor diferențelor zilnice < 0)
    var trMinus = statsTable.appendTableRow();
    trMinus.appendTableCell('Total minus normă');
    trMinus.appendTableCell(_fmtDiffMinutes_(negTotalMin));

    // Rând nou: Total diferență normă (suma tuturor diferențelor zilnice, cu semn)
    var trTotal = statsTable.appendTableRow();
    trTotal.appendTableCell('Total diferență normă');
    trTotal.appendTableCell(_fmtDiffMinutes_(totalDiffMin));

    b.appendParagraph(' ');

    // --- DETALIU PE ZILE (din "Ore zilnice" + evenimente pentru normă/pauze) ---
    if (dayKeys.length){
      b.appendParagraph('Detaliu pe zile').setHeading(DocumentApp.ParagraphHeading.HEADING2);

      var dtHeader = [
        'Data',
        'Ore',
        'Suplimentar (h)',
        'Extra (h)',
        'Client',
        'Diferență normă',
        'Start/Finish',
        'Intervale pauză (PAUSE–UNPAUSE)',
        'Intervale EXTRA (EXTRA_START–EXTRA_FINISH)',
        'Pauză totală'
      ];

      var dtTable = b.appendTable([dtHeader]);
      dtTable.getRow(0).editAsText().setBold(true);

      dayKeys.forEach(function(dayKey){
        var store = dayComputed[dayKey] || {};
        var dInfo = store.dInfo || {};
        var det   = store.det   || null;

        var diffStr = '';
        if (det && det.stdH > 0){
          diffStr = _fmtDiffMinutes_(det.diffMin || 0);
        }

      var pauseStr = '';
if (det && det.pauseMin > 0){
  pauseStr = _fmtPauseDetail_(
    det.pauseMin,
    det.pauseNormMin || 0,
    det.pauseExtraMin || 0,
    !!det.pauseExtraNull
  );
}

        var intervals = (store.intervals || {work:[], pause:[], extra:[]});

        var startFinishStr = _fmtIntervals_(intervals.work, tz);
        var pauseIntervalsStr = _fmtIntervals_(intervals.pause, tz);
        var extraIntervalsStr = _fmtIntervals_(intervals.extra, tz);

        var row = dtTable.appendTableRow();
        row.appendTableCell(dayKey);
        row.appendTableCell(_fmtHM_(dInfo.oreH || 0));
         row.appendTableCell(_fmtHM_((det && typeof det.otAdjH === "number") ? det.otAdjH : (dInfo.otH  || 0)));
        row.appendTableCell(_fmtHM_(dInfo.exH  || 0));
        row.appendTableCell(dInfo.client || '');
        row.appendTableCell(diffStr);
        row.appendTableCell(startFinishStr);
        row.appendTableCell(pauseIntervalsStr);
        row.appendTableCell(extraIntervalsStr);
        row.appendTableCell(pauseStr); // Pauză totală (rămâne)

      });

      // AICI NU mai adăugăm "TOTAL minus normă" — este acum în secțiunea "Statistici (lună)"
      b.appendParagraph(' ');
    }

    doc.saveAndClose(); Utilities.sleep(400);
    var file = DriveApp.getFileById(doc.getId());
    _moveFileToFolder_(file, fMonth);
    var pdf = file.getAs('application/pdf');
    var pdfFile = fMonth.createFile(pdf).setName('Raport_Lunar_' + name + '_' + ym + '.pdf');

    created.push({
      kind: 'monthly-employee',
      yearMonth: ym,
      employee: name,
      dept: dept,
      folderUrl: fMonth.getUrl(),
      fileUrl: pdfFile.getUrl(),
      fileName: pdfFile.getName(),
      fileId: pdfFile.getId()
    });
  });

  // 2) PDF-uri per departament (ÎNTOTDEAUNA) + STATISTICI agregate
  var deptAgg = {}; // dept -> { ym, rows: [{name, tot, ot, ex}], sumTot, sumOt, sumEx, stats }
  Object.keys(perEmp).forEach(function(name){
    var info = perEmp[name];
    var dept = _getDeptForName_(name);
    if (!deptAgg[dept]) deptAgg[dept] = { ym: info.ym, rows: [], sumTot:0, sumOt:0, sumEx:0, stats:null };
    deptAgg[dept].rows.push({ name:name, tot:info.tot, ot:info.ot, ex:info.ex });
    deptAgg[dept].sumTot += info.tot;
    deptAgg[dept].sumOt  += info.ot;
    deptAgg[dept].sumEx  += info.ex;

    var st = _computeStatsForNameInPeriod_(rVals, idx, name, monthStart, monthEnd);
    deptAgg[dept].stats = deptAgg[dept].stats ? _mergeStats_(deptAgg[dept].stats, st) : st;
  });

  // includem TOATE departamentele din CSV (și dacă n-au date luna asta)
  var csvMap = _getDeptMapByName_(false); // nameKey -> dept
  var allDepts = {};
  Object.keys(csvMap).forEach(function(k){ allDepts[csvMap[k]] = 1; });
  Object.keys(allDepts).forEach(function(d){
    if (!deptAgg[d]) {
      deptAgg[d] = {
        ym: targetYM,
        rows: [],
        sumTot:0,
        sumOt:0,
        sumEx:0,
        stats:{
          totalHours:0,totalStdHours:0,totalOvertime:0,totalPauseHours:0,totalExtraHours:0,
          actions:{start:0,pause:0,unpause:0,finish:0,extra_start:0,extra_finish:0},
          overStdCount:0,underStdCount:0
        }
      };
    }
  });

  Object.keys(deptAgg).forEach(function(dept){
    var agg = deptAgg[dept];
    var ym = agg.ym || targetYM;
    var y  = ym.split('-')[0];

    var fDept  = _ensureFolder_(baseMonthly, dept);
    var fYear  = _ensureFolder_(fDept, y);
    var fMonth = _ensureFolder_(fYear, ym);

    var doc = DocumentApp.create('Raport Lunar Departament - ' + dept + ' - ' + ym);
    var b = doc.getBody();
    b.appendParagraph('Raport Lunar Pontaj — ' + dept).setHeading(DocumentApp.ParagraphHeading.HEADING1);
    b.appendParagraph('Luna: ' + ym).setHeading(DocumentApp.ParagraphHeading.HEADING2);
    b.appendParagraph(' ');

    var header = ['Angajat','Total ore','Suplimentar (h)','Extra (h)'];
    var table = b.appendTable([header]);
    table.getRow(0).editAsText().setBold(true);

    agg.rows.sort(function(a,b){ return a.name.localeCompare(b.name, 'ro'); });
    if (agg.rows.length){
      agg.rows.forEach(function(rw){
        var tr = table.appendTableRow();
        tr.appendTableCell(String(rw.name));
        tr.appendTableCell(_fmtHM_(rw.tot));
        tr.appendTableCell(_fmtHM_(rw.ot));
        tr.appendTableCell(_fmtHM_(rw.ex));
      });
    } else {
      var tr0 = table.appendTableRow();
      tr0.appendTableCell('— niciun angajat cu pontaj în luna curentă —');
      tr0.appendTableCell('0.00');
      tr0.appendTableCell('0.00');
      tr0.appendTableCell('0.00');
    }

    var trT = table.appendTableRow();
    trT.appendTableCell('TOTAL');
    trT.appendTableCell(_fmtHM_(agg.sumTot));
    trT.appendTableCell(_fmtHM_(agg.sumOt));
    trT.appendTableCell(_fmtHM_(agg.sumEx));
    trT.getCell(0).editAsText().setBold(true);

    b.appendParagraph(' ');

    if (!agg.stats){
      agg.stats = {
        totalHours:0,totalStdHours:0,totalOvertime:0,totalPauseHours:0,totalExtraHours:0,
        actions:{start:0,pause:0,unpause:0,finish:0,extra_start:0,extra_finish:0},
        overStdCount:0,underStdCount:0
      };
    }
    _appendStatsTable_(b, agg.stats, 'Statistici departament (lună)');

    doc.saveAndClose(); Utilities.sleep(400);
    var file = DriveApp.getFileById(doc.getId());
    _moveFileToFolder_(file, fMonth);
    var pdf = file.getAs('application/pdf');
    var pdfFile = fMonth.createFile(pdf).setName('Raport_Lunar_Departament_' + dept + '_' + ym + '.pdf');

    created.push({
      kind: 'monthly-dept',
      yearMonth: ym,
      dept: dept,
      folderUrl: fMonth.getUrl(),
      fileUrl: pdfFile.getUrl(),
      fileName: pdfFile.getName(),
      fileId: pdfFile.getId()
    });
  });

  return created;
}

/**
 * monthlyReports() – rămâne pentru TRIGGER: face LUNA PRECEDENTĂ (comportamentul vechi)
 */
function monthlyReports(){
  var now = new Date();
  var year = now.getFullYear();
  var mIndex = now.getMonth() - 1;
  if (mIndex < 0){ year--; mIndex = 11; }
  var targetYM = year + '-' + ('0'+(mIndex+1)).slice(-2);
  return _monthlyReportsCore_(targetYM);
}

/**
 * monthlyReportsLatest() – NOU:
 * ia ultima lună care apare în "Total lunar" (chiar dacă nu e completă)
 * și generează raport DOAR pentru zilele pontate în acea lună.
 * -> asta o rulezi MANUAL din Apps Script.
 */
function monthlyReportsLatest(){
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName('Total lunar');
  if (!sh || sh.getLastRow() < 2) {
    Logger.log('monthlyReportsLatest: nu există date în "Total lunar".');
    return [];
  }

  var headers = _getHeaders(sh);
  var cMonth = _findCol(headers, ['luna','month']);
  if (!cMonth) {
    Logger.log('monthlyReportsLatest: nu găsesc coloana "Luna".');
    return [];
  }

  var tz = TZ_RO;
  var last = sh.getLastRow();
  var vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();
  var ymSet = {};

  function normYM(cell){
    if (Object.prototype.toString.call(cell) === '[object Date]'){
      return Utilities.formatDate(cell, tz, 'yyyy-MM');
    }
    return _norm(cell);
  }

  for (var i=0;i<vals.length;i++){
    var ym = normYM(vals[i][cMonth-1]);
    if (ym) ymSet[ym] = true;
  }

  var keys = Object.keys(ymSet);
  if (!keys.length){
    Logger.log('monthlyReportsLatest: niciun YM valid în "Total lunar".');
    return [];
  }

  keys.sort(); // "2025-01" < "2025-02" < "2025-12" < "2026-01"
  var targetYM = keys[keys.length - 1];
  Logger.log('monthlyReportsLatest: targetYM = ' + targetYM);

  return _monthlyReportsCore_(targetYM);
}


/*********************** CONCEDII — WEB APP ************************/

var HR_TO = 'office@servelect.ro';
var LEAVE_TYPES = {
  'concediu de odihna': true,
  'concediu medical': true,
  'concediu pentru ore suplimentare': true
};

function ensureConcediiSheet_() {
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var sh = ss.getSheetByName('Concedii');
  if (!sh) sh = ss.insertSheet('Concedii');
  if (sh.getLastRow() === 0) {
    sh.appendRow(['Data cererii','Nume','Tip concediu','Start','Sfârșit','Zile','Email personal','Notă','Status email','Zile alese']);
    sh.getRange('A2:A').setNumberFormat('yyyy-MM-dd HH:mm');
    sh.getRange('D2:E').setNumberFormat('yyyy-MM-dd');
    sh.getRange('F2:F').setNumberFormat('0');
  }
  return sh;
}

function safeSendEmail(opts) {
  var BLOCKED_RECIPIENTS = [/@googlegroups\.com$/i];
  var toList = String(opts.to || '')
    .split(',')
    .map(function(s){ return s.trim(); })
    .filter(function(addr){
      return addr && !BLOCKED_RECIPIENTS.some(function(rx){ return rx.test(addr); });
    });
  if (!toList.length) { Logger.log('safeSendEmail: destinatar blocat/gol: ' + JSON.stringify(opts)); return; }
  opts.to = toList.join(', ');
  MailApp.sendEmail(opts);
}

function jsonResp_(obj){
  return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON);
}

function jsonResp_(obj){
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

// ✅ pune asta imediat SUB jsonResp_()
function jsonpResp_(e, obj){
  var cb = _norm(e && e.parameter && e.parameter.callback);
  if (cb){
    var js = cb + '(' + JSON.stringify(obj) + ');';
    return ContentService
      .createTextOutput(js)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }
  return jsonResp_(obj);
}

/*********************** ADMIN: MANAGERS MAP ************************/

/**
 * Admin key: prefer Script Property 'ADMIN_KEY' if set, otherwise fallback hardcoded.
 */
function _adminKeyRequired_(){
  var k = '';
  try{ k = PropertiesService.getScriptProperties().getProperty('ADMIN_KEY') || ''; }catch(_){}
  if (k && String(k).trim()) return String(k).trim();
  return 'Servelect_2026!_AdminKey';
}

function _checkAdminKey_(e){
  var req = _adminKeyRequired_();
  var p = (e && e.parameter) ? e.parameter : {};
  var got = _norm(p.key || p.k || p.adminKey || p.ak || '');
  if (!got || got !== req){
    return { ok:false, error:'unauthorized', message:'ADMIN_KEY invalid.' };
  }
  return { ok:true };
}

function _ensureManagersSheet_(){
  var ss = _pontajSs_();
  var sh = ss.getSheetByName('Managers');
  if (!sh){
    sh = ss.insertSheet('Managers');
    sh.getRange(1,1,1,6).setValues([['nameKey','name','email','managerName','updatedAt','updatedBy']]);
    sh.setFrozenRows(1);
  }else if (sh.getLastRow() === 0){
    sh.getRange(1,1,1,6).setValues([['nameKey','name','email','managerName','updatedAt','updatedBy']]);
    sh.setFrozenRows(1);
  }
  return sh;
}

function _readManagersMap_(){
  var sh = _ensureManagersSheet_();
  var lastRow = sh.getLastRow();
  var res = {};
  if (lastRow < 2) return res;

  var vals = sh.getRange(2,1,lastRow-1,6).getValues();
  for (var i=0;i<vals.length;i++){
    var row = vals[i];
    var nameKey = _norm(row[0] || row[1] || '');
    if (!nameKey) continue;
    var email = _norm(row[2] || '');
    var managerName = String(row[3] || '');
    var updatedAt = String(row[4] || '');
    var updatedBy = String(row[5] || '');

    // keep rows even if cleared? frontend expects absence; we'll skip if no email
    if (!email) continue;

    res[nameKey.toLowerCase()] = { email: email, name: managerName, updatedAt: updatedAt, updatedBy: updatedBy };
  }
  return res;
}

function _handleAdminManagersMap_(e){
  var g = _checkAdminKey_(e);
  if (!g.ok) return jsonpResp_(e, g);
  try{
    var mp = _readManagersMap_();
    return jsonpResp_(e, { ok:true, map: mp });
  }catch(err){
    return jsonpResp_(e, { ok:false, error:String(err && err.message ? err.message : err) });
  }
}

function _handleAdminSetManager_(e){
  var g = _checkAdminKey_(e);
  if (!g.ok) return jsonpResp_(e, g);

  var p = (e && e.parameter) ? e.parameter : {};
  var name = String(p.name || p.employeeName || p.empName || '').trim();
  var employeeKey = String(p.employeeKey || '').trim();
  if (!name && employeeKey) name = employeeKey;

  if (!name) return jsonpResp_(e, { ok:false, error:'bad_request', message:'Lipsește param name/employeeKey.' });

  var nameKey = _norm(name).toLowerCase();
  if (!nameKey) return jsonpResp_(e, { ok:false, error:'bad_request', message:'Nume invalid.' });

  var mgrEmail = String(p.managerEmail || p.email || '').trim();
  var mgrName = String(p.managerName || '').trim();

  // minimal validation when setting
  if (mgrEmail && mgrEmail.indexOf('@') === -1){
    return jsonpResp_(e, { ok:false, error:'bad_request', message:'managerEmail invalid.' });
  }

  var updatedAt = new Date().toISOString();
  var updatedBy = String(p.updatedBy || '').trim();
  try{
    var me = Session.getActiveUser().getEmail();
    if (me) updatedBy = me;
  }catch(_){}

  var lock = LockService.getScriptLock();
  lock.waitLock(8000);
  try{
    var sh = _ensureManagersSheet_();
    var lastRow = sh.getLastRow();

    var targetRow = -1;
    if (lastRow >= 2){
      var keys = sh.getRange(2,1,lastRow-1,1).getValues();
      for (var i=0;i<keys.length;i++){
        var k = _norm(keys[i][0] || '').toLowerCase();
        if (k === nameKey){ targetRow = 2+i; break; }
      }
    }

    if (!mgrEmail){
      // clear -> delete row if exists
      if (targetRow !== -1){
        sh.deleteRow(targetRow);
      }
    } else {
      var row = [nameKey, name, mgrEmail, mgrName, updatedAt, updatedBy];
      if (targetRow === -1){
        sh.appendRow(row);
      } else {
        sh.getRange(targetRow,1,1,6).setValues([row]);
      }
    }

    var mp = _readManagersMap_();
    return jsonpResp_(e, { ok:true, map: mp, updatedAt: updatedAt, updatedBy: updatedBy });

  }catch(err){
    return jsonpResp_(e, { ok:false, error:String(err && err.message ? err.message : err) });
  }finally{
    try{ lock.releaseLock(); }catch(_){}
  }
}

/*********************** WEBAPP: STATE, STATS, GUARD & LEAVE ************************/

// --- Cache pentru state per angajat (în CacheService, TTL 60s) ---
function _getCachedState_(name){
  try {
    var cache = CacheService.getScriptCache();
    var key = 'state:' + _normKeyName_(name);
    var raw = cache.get(key);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch(e){
    return null;
  }
}
function _setCachedState_(name, state){
  try {
    var cache = CacheService.getScriptCache();
    var key = 'state:' + _normKeyName_(name);
    cache.put(key, JSON.stringify(state), 60); // secunde
  } catch(e){}
}

// --- Mic "lock" pentru guard, ca să prevenim dublu-click pe același buton ---
function _getGuardRecent_(name){
  try{
    var cache = CacheService.getScriptCache();
    var key = 'guard_recent:' + _normKeyName_(name);
    var raw = cache.get(key);
    if (!raw) return null;
    return JSON.parse(raw);
  } catch(e){
    return null;
  }
}
function _setGuardRecent_(name, obj){
  try{
    var cache = CacheService.getScriptCache();
    var key = 'guard_recent:' + _normKeyName_(name);
    // 10s este suficient ca să ajungă formularul în foaie și să evite dublu-click
    cache.put(key, JSON.stringify(obj), 10);
  } catch(e){}
}

function _computeStateForName_(name, bypassCache){
  name = _norm(name || '');
  if (!name){
    return {
      ok:true,
      state:{
        name:'',
        normal:{running:false, paused:false},
        extra:{running:false},
        lastNormalStart:null,lastNormalFinish:null,
        lastExtraStart:null,lastExtraFinish:null
      }
    };
  }

  // încearcă cache (doar dacă nu vrem bypass)
  if (!bypassCache){
    var cached = _getCachedState_(name);
    if (cached){
      return { ok:true, state: cached };
    }
  }

  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);
  if (!headers.length || sh.getLastRow() < 2) {
    var stEmpty = {
      name:name,
      normal:{running:false, paused:false},
      extra:{running:false},
      lastNormalStart:null,lastNormalFinish:null,
      lastExtraStart:null,lastExtraFinish:null
    };
    _setCachedState_(name, stEmpty);
    return { ok:true, state: stEmpty };
  }
  var cTs  = headers.indexOf('Timestamp')+1 || _findCol(headers,['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cAc  = _findCol(headers,['f_action','action','actiune','acțiune']);
  if (!cTs||!cNm||!cAc) {
    var stFallback = { name:name, normal:{running:false,paused:false}, extra:{running:false} };
    _setCachedState_(name, stFallback);
    return { ok:true, state:stFallback };
  }

  var vals = sh.getRange(2,1,sh.getLastRow()-1, sh.getLastColumn()).getValues();
  var rows = [];
  for (var i=0;i<vals.length;i++){
    if (!_samePerson(vals[i][cNm-1], name)) continue;
    var a=_normAction(vals[i][cAc-1]);
    var t=_toDate(vals[i][cTs-1]);
    if (!t) continue;
    rows.push({t:t,a:a});
  }
  rows.sort(function(x,y){ return x.t - y.t; });

  var state = {
    name:name,
    normal:{running:false, paused:false},
    extra:{running:false},
    lastNormalStart:null,lastNormalFinish:null,
    lastExtraStart:null,lastExtraFinish:null
  };

  for (var r=0;r<rows.length;r++){
    var a = rows[r].a, t = rows[r].t.toISOString();
    if (a==='start'){ state.normal.running=true; state.normal.paused=false; state.lastNormalStart=t; }
    else if (a==='pause' && state.normal.running){ state.normal.paused=true; }
    else if (a==='unpause' && state.normal.running){ state.normal.paused=false; }
    else if (a==='finish'){ state.normal.running=false; state.normal.paused=false; state.lastNormalFinish=t; }
    else if (a==='extra_start'){ state.extra.running=true; state.lastExtraStart=t; }
    else if (a==='extra_finish'){ state.extra.running=false; state.lastExtraFinish=t; }
  }

  _setCachedState_(name, state);
  return { ok:true, state:state };
}

// === Fallback LIVE pentru stats din foaie (azi)
function _todayYMD_(){
  var d = new Date(); d.setHours(0,0,0,0);
  return Utilities.formatDate(d, TZ_RO, 'yyyy-MM-dd');
}
function _computeTodayStatsFromSheet_(name){
  name = _norm(name);
  if (!name) return {totalHours:0,overtime:0,extra:0};
  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  if (!sh || sh.getLastRow() < 2) return {totalHours:0,overtime:0,extra:0};
  var headers = _getHeaders(sh);
  var cTs  = headers.indexOf('Timestamp') + 1; if(!cTs)  cTs  = _findCol(headers,['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cDur = _findCol(headers,['durata (ore)','duration(h)','durata']);
  var cOT  = _findCol(headers,['suplimentar (h)','overtime','suplimentar']);
  var cEX  = _findCol(headers,['extra (h)','extra']);
  if(!cTs || !cNm) return {totalHours:0,overtime:0,extra:0};

  var tz = TZ_RO;
  var today = _todayYMD_();

  var vals = sh.getRange(2,1, sh.getLastRow()-1, sh.getLastColumn()).getValues();
  var H=0, OT=0, EX=0;

  for (var i=0;i<vals.length;i++){
    if (!_samePerson(vals[i][cNm-1], name)) continue;
    var ts = _toDate(vals[i][cTs-1]); if(!ts) continue;
    var d = new Date(ts); d.setHours(0,0,0,0);
    var ymd = Utilities.formatDate(d, tz, 'yyyy-MM-dd');
    if (ymd !== today) continue;

    var h  = cDur ? _asHours(vals[i][cDur-1]) : 0;
    var ot = cOT  ? _num(vals[i][cOT-1])      : Math.max(0, h - 8);
    var ex = cEX  ? _num(vals[i][cEX-1])      : 0;

    H += (h||0);
    OT += (ot||0);
    EX += (ex||0);
  }
  return { totalHours:_round2(H), overtime:_round2(OT), extra:_round2(EX) };
}

// Citește rapid din ScriptProperties; dacă e gol sau 0, cade pe live
function _getTodayStats_(name){
  name = _norm(name);
  var raw = PropertiesService.getScriptProperties().getProperty('daily_details_json');
  var map = {};
  try { map = raw ? JSON.parse(raw) : {}; } catch(e){ map = {}; }
  var key = name + '|' + _todayYMD_();
  var v = map[key];

  if (v && (v.h>0 || v.ot>0 || v.ex>0)) {
    return {
      totalHours: _round2(_num(v.h)||0),
      overtime:   _round2(_num(v.ot)||0),
      extra:      _round2(_num(v.ex)||0)
    };
  }
  // fallback live
  return _computeTodayStatsFromSheet_(name);
}

function _guardAction_(state, action){
  action = _normAction(action);
  var running = state.normal.running;
  var paused  = state.normal.paused;
  var extraR  = state.extra.running;

  switch(action){
    case 'start':
      if (running)  return {ok:false,msg:'Ai deja START activ.'};
      if (extraR)   return {ok:false,msg:'Finalizează „EXTRA” înainte de START.'};
      return {ok:true};
    case 'pause':
      if (!running) return {ok:false,msg:'Nu poți PAUSE fără START.'};
      if (paused)   return {ok:false,msg:'Ești deja în PAUSE.'};
      return {ok:true};
    case 'unpause':
      if (!running) return {ok:false,msg:'Nu poți UNPAUSE fără START.'};
      if (!paused)  return {ok:false,msg:'Nu ești în PAUSE.'};
      return {ok:true};
    case 'finish':
      if (!running) return {ok:false,msg:'Nu poți FINISH fără START.'};
      if (paused)   return {ok:false,msg:'Nu poți FINISH în PAUSE — apasă UNPAUSE mai întâi.'};
      return {ok:true};
    case 'extra_start':
      if (running)  return {ok:false,msg:'Închide norma (FINISH) înainte de EXTRA START.'};
      if (extraR)   return {ok:false,msg:'EXTRA este deja pornit.'};
      return {ok:true};
    case 'extra_finish':
      if (!extraR)  return {ok:false,msg:'Nu poți EXTRA FINISH fără EXTRA START.'};
      return {ok:true};
    default:
      return {ok:false,msg:'Acțiune necunoscută: '+action};
  }
}

/**
 * Admin endpoint: statistici agregate pentru dashboard
 * GET ?fn=adminEvents&from=YYYY-MM-DD&to=YYYY-MM-DD&dept=...&name=...
 */
/**
 * Admin endpoint: statistici agregate pentru dashboard
 * GET ?fn=adminEvents&from=YYYY-MM-DD&to=YYYY-MM-DD&dept=...&name=...
 *
 * Returnează:
 * {
 *   ok: true,
 *   meta: {...},
 *   events: [...],          // <-- pentru frontend (log brut, ultimele pontaje etc.)
 *   employees: [...],       // sumar per angajat
 *   dailyCompletion: [...]  // completare pe zile
 * }
 */
function _handleAdminEvents_(e){
  var params = (e && e.parameter) || {};
  var fromStr = _norm(params.from || '');
  var toStr   = _norm(params.to   || '');
  var deptFilterRaw = _norm(params.dept || '');
  var nameFilterRaw = _norm(params.name || '');

  var now = new Date();
  var tz = TZ_RO;

  // --- interpretăm from/to ca ZILE complete (00:00:00–23:59:59) ---
  function _parseYMD_(s, endOfDay){
    if (!s) return null;
    var m = String(s).match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (!m) return null;
    var d = new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
    if (endOfDay){
      d.setHours(23,59,59,999);
    } else {
      d.setHours(0,0,0,0);
    }
    return d;
  }

  var from = fromStr ? _parseYMD_(fromStr, false) : null;
  var to   = toStr   ? _parseYMD_(toStr,   true)  : null;

  // fallback: luna curentă
  if (!from || !to){
    var y = now.getFullYear();
    var m = now.getMonth();
    from = new Date(y, m, 1);     from.setHours(0,0,0,0);
    to   = new Date(y, m+1, 0);   to.setHours(23,59,59,999);
  }
  if (from > to){
    var tmp = from; from = to; to = tmp;
  }

  var deptFilter = deptFilterRaw ? _deaccent(deptFilterRaw).toLowerCase() : '';
  var hasDeptFilter = !!deptFilter;
  var nameFilterKey = nameFilterRaw ? _normKeyName_(nameFilterRaw) : '';
  var hasNameFilter = !!nameFilterKey;

  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);

  if (!headers.length || sh.getLastRow() < 2){
    return jsonResp_({
      ok:true,
      meta:{
        from: Utilities.formatDate(from, tz, 'yyyy-MM-dd'),
        to: Utilities.formatDate(to,   tz, 'yyyy-MM-dd'),
        tz: tz,
        generatedAt: new Date().toISOString(),
        deptFilter: deptFilterRaw || null,
        nameFilter: nameFilterRaw || null
      },
      events: [],
      employees:[],
      dailyCompletion:[]
    });
  }

  var cTs  = headers.indexOf('Timestamp')+1;
  if (!cTs) cTs = _findCol(headers,['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cAc  = _findCol(headers,['f_action','action','actiune','acțiune']);
  var cDur = _findCol(headers,['durata (ore)','duration(h)','durata']);
  var cOT  = _findCol(headers,['suplimentar (h)','overtime','suplimentar']);
  var cEX  = _findCol(headers,['extra (h)','extra']);
  var cAct = _findCol(headers,['tip de activitate','activity type','tip activitate','activitate']);
  var cLoc = _findCol(headers,['locație','locatie','location']);
  var cDept = _findCol(headers,['departament','department','dept']);

  if (!cTs || !cNm || !cAc){
    return jsonResp_({ ok:false, error:'Nu găsesc coloanele esențiale (Timestamp/Nume/Acțiune).' });
  }

  var last = sh.getLastRow();
  var vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();

  // --- colecții pentru stats + lista de evenimente brute ---
  var events = [];
  var namesSet = {};
  var deptByName = {};
  var daysWithEvents = {};
  var daysWithFinish = {};
  var eventsByDay = {};
  var finishByDay = {};

  for (var i=0;i<vals.length;i++){
    var row = vals[i];

    var ts = _toDate(row[cTs-1]); 
    if (!ts) continue;
    if (ts < from || ts > to) continue;

    var nm = _norm(row[cNm-1]); 
    if (!nm) continue;

    var keyName = _normKeyName_(nm);
    if (hasNameFilter && keyName !== nameFilterKey) continue;

    var deptVal = '';
    if (cDept){
      deptVal = _norm(row[cDept-1]);
    }
    if (!deptVal){
      deptVal = _getDeptForName_(nm);
    }
    var deptNorm = _deaccent(deptVal).toLowerCase();
    if (hasDeptFilter && deptNorm !== deptFilter) continue;

    var action = _normAction(row[cAc-1]);
    var dur  = cDur ? _asHours(row[cDur-1]) : 0;
    var ot   = cOT  ? _num(row[cOT-1])      : Math.max(0, dur - 8);
    var ex   = cEX  ? _num(row[cEX-1])      : 0;
    var actV = cAct ? _norm(row[cAct-1])    : '';
    var locV = cLoc ? _norm(row[cLoc-1])    : '';
    var dayKey = _ymdInTZ_(ts, TZ_RO);
    var timeStr = Utilities.formatDate(ts, TZ_RO, 'HH:mm:ss');

    events.push({
      name: nm,
      dept: deptVal,
      ts: ts.toISOString(),
      day: dayKey,
      time: timeStr,
      action: action,
      activity: actV,
      location: locV,
      duration: _round2(dur),
      overtime: _round2(ot),
      extra: _round2(ex),
      row: i+2
    });

    namesSet[nm] = true;
    if (!deptByName[nm]) deptByName[nm] = deptVal || '';

    if (!daysWithEvents[nm]) daysWithEvents[nm] = {};
    daysWithEvents[nm][dayKey] = true;

    if (!eventsByDay[dayKey]) eventsByDay[dayKey] = {};
    eventsByDay[dayKey][keyName] = true;

    if (action === 'finish'){
      if (!daysWithFinish[nm]) daysWithFinish[nm] = {};
      daysWithFinish[nm][dayKey] = true;

      if (!finishByDay[dayKey]) finishByDay[dayKey] = {};
      finishByDay[dayKey][keyName] = true;
    }
  }

  var idx = { iNm:cNm-1, iAc:cAc-1, iTs:cTs-1, iAct:(cAct?cAct-1:-1), iLoc:(cLoc?cLoc-1:-1) };
  var employees = [];
  for (var nm in namesSet){
    if (!namesSet.hasOwnProperty(nm)) continue;
    var stats = _computeStatsForNameInPeriod_(vals, idx, nm, from, to);
    var dpt = deptByName[nm] || _getDeptForName_(nm);
    var evDays = daysWithEvents[nm] ? Object.keys(daysWithEvents[nm]).length : 0;
    var finDays = daysWithFinish[nm] ? Object.keys(daysWithFinish[nm]).length : 0;
    var rate = evDays ? _round2(finDays / evDays) : null;

    employees.push({
      name: nm,
      dept: dpt,
      totalHours: stats.totalHours,
      totalStdHours: stats.totalStdHours,
      overtime: stats.totalOvertime,
      extra: stats.totalExtraHours,
      pauseHours: stats.totalPauseHours,
      actions: stats.actions,
      overStdCount: stats.overStdCount,
      underStdCount: stats.underStdCount,
      daysWithEvents: evDays,
      finishedDays: finDays,
      completionRate: rate
    });
  }
  employees.sort(function(a,b){
    var d = (a.dept||'').localeCompare(b.dept||'', 'ro');
    if (d !== 0) return d;
    return a.name.localeCompare(b.name, 'ro');
  });

  var dailyCompletion = [];
  var dayKeys = Object.keys(eventsByDay).sort();
  for (var dIdx=0; dIdx<dayKeys.length; dIdx++){
    var dk = dayKeys[dIdx];
    var total = eventsByDay[dk] ? Object.keys(eventsByDay[dk]).length : 0;
    var done = finishByDay[dk] ? Object.keys(finishByDay[dk]).length : 0;
    dailyCompletion.push({
      day: dk,
      withEvents: total,
      finished: done,
      notFinished: Math.max(0, total - done)
    });
  }

  var meta = {
    from: Utilities.formatDate(from, tz, 'yyyy-MM-dd'),
    to:   Utilities.formatDate(to,   tz, 'yyyy-MM-dd'),
    tz: tz,
    generatedAt: new Date().toISOString(),
    deptFilter: deptFilterRaw || null,
    nameFilter: nameFilterRaw || null
  };

return jsonpResp_(e, {
  ok:true,
  meta: meta,
  events: events,
  employees: employees,
  dailyCompletion: dailyCompletion
});

}

/**
 * Admin endpoint: raport lunar PDF pentru un departament (luna precedentă)
 * GET ?fn=adminPdfDept&dept=NumeDepartament
 */
function _handleAdminPdfDept_(e){
  var params = (e && e.parameter) || {};
  var dept = _norm(params.dept || '');
  if (!dept){
    return jsonResp_({ ok:false, error:'Lipsește param dept.' });
  }

  var now = new Date();
  var year = now.getFullYear();
  var mIndex = now.getMonth() - 1;
  if (mIndex < 0){ year--; mIndex = 11; }
  var ym = year + '-' + ('0'+(mIndex+1)).slice(-2);

  try{
    monthlyReports();
  } catch(err){
    Logger.log('adminPdfDept: eroare la monthlyReports: ' + err);
  }

  var root = _getReportsRoot_();
  var baseMonthly = _ensureFolder_(root, 'Pontaj - Rapoarte Lunare');

  var itDept = baseMonthly.getFoldersByName(dept);
  if (!itDept.hasNext()){
    return jsonResp_({ ok:false, error:'Nu există folder pentru departamentul "'+dept+'".' });
  }
  var fDept = itDept.next();

  var itYear = fDept.getFoldersByName(String(year));
  if (!itYear.hasNext()){
    return jsonResp_({ ok:false, error:'Nu există rapoarte pentru anul ' + year + ' (departament ' + dept + ').' });
  }
  var fYear = itYear.next();

  var itMonth = fYear.getFoldersByName(ym);
  if (!itMonth.hasNext()){
    return jsonResp_({ ok:false, error:'Nu există rapoarte pentru luna ' + ym + ' (departament ' + dept + ').' });
  }
  var fMonth = itMonth.next();

  var name = 'Raport_Lunar_Departament_' + dept + '_' + ym + '.pdf';
  var itFile = fMonth.getFilesByName(name);
  var file;
  if (itFile.hasNext()){
    file = itFile.next();
  } else {
    var itAny = fMonth.getFiles();
    if (!itAny.hasNext()){
      return jsonResp_({ ok:false, error:'Nu există niciun fișier PDF în folderul ' + ym + ' pentru departament.' });
    }
    file = itAny.next();
  }

  return jsonResp_({
    ok:true,
    url: file.getUrl(),
    name: file.getName(),
    ym: ym,
    dept: dept
  });
}

/**
 * Ia datele de la endpoint-ul adminEvents al aceluiași web app.
 */
function _fetchAdminEventsData_(){
  var baseUrl = ScriptApp.getService().getUrl();
  if (!baseUrl){
    throw new Error('Nu pot determina URL-ul web app-ului (ScriptApp.getService().getUrl()).');
  }
  var url = baseUrl + '?fn=adminEvents&source=adminPdf';
  var resp = UrlFetchApp.fetch(url, { muteHttpExceptions: true });
  var code = resp.getResponseCode();
  if (code !== 200){
    throw new Error('adminEvents HTTP ' + code);
  }
  var text = resp.getContentText();
  var data;
  try {
    data = JSON.parse(text);
  } catch(e){
    throw new Error('Răspuns invalid de la adminEvents: ' + e);
  }
  if (!data || !data.ok || !Array.isArray(data.events)){
    throw new Error('adminEvents nu a întors un obiect ok cu events[].');
  }

  var events = data.events.map(function(ev){
    return {
      ts: ev.ts,
      name: ev.name || '',
      action: _adminNormAction_(ev.action),
      dept: ev.dept || '',
      activity: ev.activity || '',
      location: ev.location || ''
    };
  }).filter(function(ev){ return ev.ts; });

  return {
    events: events,
    meta: data.meta || null
  };
}

function _adminNormAction_(a){
  var s = (a == null ? '' : String(a)).toLowerCase().replace(/[-\s]+/g, '_');
  if (s === 'resume') s = 'unpause';
  if (s === 'stop') s = 'finish';
  if (s === 'extra_start') s = 'extra_start';
  if (s === 'extra_finish') s = 'extra_finish';
  return s;
}

function _adminDateKeyFromIso_(iso){
  if (!iso) return null;
  var d = new Date(iso);
  if (isNaN(d.getTime())) return null;
  var y = d.getFullYear();
  var m = ('0' + (d.getMonth() + 1)).slice(-2);
  var dd = ('0' + d.getDate()).slice(-2);
  return y + '-' + m + '-' + dd;
}

/**
 * Copie 1:1 a algoritmului din admin.html (buildStatsFromEvents),
 * dar pe backend (pentru generarea PDF-urilor).
 */
function _buildAdminStats_(events){
  var employees = new Map();
  var perDay = new Map();
  var NORM_MS = 8 * 60 * 60 * 1000;

  function getEmp(name){
    if (!employees.has(name)){
      employees.set(name, {
        name: name,
        dept: '',
        days: new Map(),
        totals: {
          daysWithStart: 0,
          daysWithFinish: 0,
          daysCompleted: 0,
          totalWorkMs: 0,
          totalExtraMs: 0,
          overtimeMs: 0,
          firstEvent: null,
          lastEvent: null
        }
      });
    }
    return employees.get(name);
  }

  var byNameDate = new Map();
  (events || []).forEach(function(ev){
    if (!ev.ts || !ev.name) return;
    var dk = _adminDateKeyFromIso_(ev.ts);
    if (!dk) return;
    var key = ev.name + '||' + dk;
    if (!byNameDate.has(key)) byNameDate.set(key, []);
    byNameDate.get(key).push(ev);
  });

  byNameDate.forEach(function(evs, key){
    evs.sort(function(a,b){ return new Date(a.ts) - new Date(b.ts); });

    var parts = key.split('||');
    var name = parts[0];
    var dk = parts[1];

    var emp = getEmp(name);
    var day = emp.days.get(dk);
    if (!day){
      day = {
        dateKey: dk,
        dept: '',
        events: evs,
        workMs: 0,
        extraMs: 0,
        hasStart: false,
        hasFinish: false,
        completed: false,
        overtimeMs: 0
      };
      emp.days.set(dk, day);
    }

    evs.forEach(function(ev){
      if (ev.dept) day.dept = ev.dept;
    });
    if (!emp.dept && day.dept) emp.dept = day.dept;

    var running = false;
    var paused = false;
    var extraRunning = false;
    var startTs = null;
    var pauseStartTs = null;
    var extraStartTs = null;
    var sumPauseMs = 0;
    var workMs = 0;
    var extraMs = 0;

    evs.forEach(function(ev){
      var t = new Date(ev.ts).getTime();
      if (isNaN(t)) return;
      var act = ev.action;

      if (act === 'start') {
        day.hasStart = true;
        if (!running) {
          running = true;
          paused = false;
          sumPauseMs = 0;
          startTs = t;
          pauseStartTs = null;
        }
      } else if (act === 'pause') {
        if (running && !paused) {
          paused = true;
          pauseStartTs = t;
        }
      } else if (act === 'unpause') {
        if (running && paused) {
          paused = false;
          if (pauseStartTs != null) {
            sumPauseMs += Math.max(0, t - pauseStartTs);
            pauseStartTs = null;
          }
        }
      } else if (act === 'finish') {
        day.hasFinish = true;
        if (running && startTs != null) {
          if (paused && pauseStartTs != null) {
            sumPauseMs += Math.max(0, t - pauseStartTs);
            pauseStartTs = null;
            paused = false;
          }
          var diff = Math.max(0, t - startTs);
          var segment = Math.max(0, diff - sumPauseMs);
          workMs += segment;
        }
        running = false;
        paused = false;
        startTs = null;
        pauseStartTs = null;
        sumPauseMs = 0;
      } else if (act === 'extra_start') {
        if (!extraRunning) {
          extraRunning = true;
          extraStartTs = t;
        }
      } else if (act === 'extra_finish') {
        if (extraRunning && extraStartTs != null) {
          extraMs += Math.max(0, t - extraStartTs);
        }
        extraRunning = false;
        extraStartTs = null;
      }
    });

    day.workMs = workMs;
    day.extraMs = extraMs;
    if (day.hasStart) emp.totals.daysWithStart++;
    if (day.hasFinish) emp.totals.daysWithFinish++;
    if (day.hasStart && day.hasFinish && workMs > 0) {
      day.completed = true;
      emp.totals.daysCompleted++;
      if (workMs > NORM_MS) {
        day.overtimeMs = workMs - NORM_MS;
        emp.totals.overtimeMs += day.overtimeMs;
      }
    }
    emp.totals.totalWorkMs += workMs;
    emp.totals.totalExtraMs += extraMs;

    evs.forEach(function(ev){
      var t = new Date(ev.ts).getTime();
      if (isNaN(t)) return;
      if (!emp.totals.firstEvent || t < new Date(emp.totals.firstEvent).getTime()) {
        emp.totals.firstEvent = ev.ts;
      }
      if (!emp.totals.lastEvent || t > new Date(emp.totals.lastEvent).getTime()) {
        emp.totals.lastEvent = ev.ts;
      }
    });

    var daySummary = perDay.get(dk);
    if (!daySummary) {
      daySummary = { dateKey: dk, started: new Set(), completed: new Set() };
      perDay.set(dk, daySummary);
    }
    if (day.hasStart) daySummary.started.add(name);
    if (day.completed) daySummary.completed.add(name);
  });

  return {
    employees: employees,
    perDay: perDay
  };
}

function _adminFmtHours_(ms){
  return _fmtMsHM_(ms);
}

function _fmtPauseDetail_(pauseMin, pauseNormMin, pauseExtraMin, pauseExtraNull){
  pauseMin = Math.round(Number(pauseMin || 0));
  if (pauseMin <= 0) return '';

  var base = _fmtMsHM_(pauseMin * 60000);

  var parts = [];
  parts.push('normă ' + _fmtMsHM_((pauseNormMin || 0) * 60000));

  if ((pauseExtraMin || 0) > 0){
    var s = 'extra ' + _fmtMsHM_(pauseExtraMin * 60000);
    if (pauseExtraNull) s += ' (nul)';
    parts.push(s);
  }

  return base + ' (' + parts.join(' + ') + ')';
}


function _adminTodayYMD_(){
  var d = new Date();
  var y = d.getFullYear();
  var m = ('0' + (d.getMonth()+1)).slice(-2);
  var dd = ('0' + d.getDate()).slice(-2);
  return y + '-' + m + '-' + dd;
}

/**
 * Endpoint: fn=adminPdf&name=Nume Angajat
 * Creează un Google Doc cu raportul, îl salvează ca PDF într-un folder
 * /Pontaj - Rapoarte Angajati/[YYYY]/ și întoarce url-ul PDF-ului ca JSON.
 */
function _handleAdminPdf_(e){
  var params = (e && e.parameter) || {};
  var name = (params.name || '').trim();
  if (!name){
    return jsonResp_({ ok:false, error:'Lipsește param name (nume angajat).' });
  }

  var data = _fetchAdminEventsData_();
  var allEvents = data.events || [];
  if (!allEvents.length){
    return jsonResp_({ ok:false, error:'Nu există evenimente în sistem.' });
  }

  var eventsForEmp = allEvents.filter(function(ev){
    return String(ev.name || '') === name;
  });
  if (!eventsForEmp.length){
    return jsonResp_({ ok:false, error:'Nu există evenimente pentru angajatul "' + name + '".' });
  }

  var stats = _buildAdminStats_(eventsForEmp);
  var empEntry = stats.employees.get(name);
  if (!empEntry){
    return jsonResp_({ ok:false, error:'Nu am putut calcula statistici pentru "' + name + '".' });
  }
  var t = empEntry.totals;

  var daysArr = Array.from(empEntry.days.values()).sort(function(a,b){
    if (a.dateKey < b.dateKey) return -1;
    if (a.dateKey > b.dateKey) return 1;
    return 0;
  });

  var pctComplete = t.daysWithStart
    ? Math.round(100 * t.daysCompleted / t.daysWithStart)
    : 0;

  var docName = 'Raport_Pontaj_' + name.replace(/\s+/g, '_') + '_' + _adminTodayYMD_();

  var root = _getReportsRoot_();
  var base = _ensureFolder_(root, 'Pontaj - Rapoarte Angajati');
  var year = String(new Date().getFullYear());
  var fYear = _ensureFolder_(base, year);

  var doc = DocumentApp.create(docName);
  var body = doc.getBody();

  body.appendParagraph('Raport pontaj – ' + name)
      .setHeading(DocumentApp.ParagraphHeading.HEADING1);

  body.appendParagraph(
    'Generat la: ' +
    Utilities.formatDate(
      new Date(),
      Session.getScriptTimeZone() || 'Europe/Bucharest',
      'dd.MM.yyyy HH:mm'
    )
  );

  if (empEntry.dept){
    body.appendParagraph('Departament: ' + empEntry.dept);
  }

  body.appendParagraph('');

  var summary = [
    'Total ore normă: ' + _adminFmtHours_(t.totalWorkMs),
    'Total ore extra: ' + _adminFmtHours_(t.totalExtraMs),
    'Total overtime: ' + _adminFmtHours_(t.overtimeMs),
    'Zile cu START: ' + t.daysWithStart,
    'Zile cu FINISH: ' + t.daysWithFinish,
    'Zile complete: ' + t.daysCompleted + ' (' + pctComplete + '%)'
  ].join('\n');

  body.appendParagraph(summary);
  body.appendParagraph('');

  var tbl = body.appendTable();
  var headerRow = tbl.appendTableRow();
  ['Data','Departament','Normă','Extra','Completă','Overtime'].forEach(function(h){
    headerRow.appendTableCell(h);
  });

  daysArr.forEach(function(d){
    var row = tbl.appendTableRow();
    row.appendTableCell(d.dateKey);
    row.appendTableCell(d.dept || '');
    row.appendTableCell(d.workMs ? _adminFmtHours_(d.workMs) : '-');
    row.appendTableCell(d.extraMs ? _adminFmtHours_(d.extraMs) : '-');

    var status;
    if (d.completed) status = 'DA';
    else if (d.hasStart || d.hasFinish) status = 'INCOMPLETĂ';
    else status = '-';

    row.appendTableCell(status);
    row.appendTableCell(d.overtimeMs ? _adminFmtHours_(d.overtimeMs) : '-');
  });

  doc.saveAndClose();

  var docFile = DriveApp.getFileById(doc.getId());
  fYear.addFile(docFile);
  try {
    DriveApp.getRootFolder().removeFile(docFile);
  } catch(err){}

  var pdfBlob = doc.getAs('application/pdf');
  pdfBlob.setName(docName + '.pdf');
  var pdfFile = fYear.createFile(pdfBlob);

  return jsonResp_({
    ok: true,
    url: pdfFile.getUrl(),
    name: pdfFile.getName(),
    employee: name
  });
}

/**
 * Endpoint: fn=adminPdf&name=...&from=YYYY-MM-DD&to=YYYY-MM-DD
 * (versiune extinsă bazată pe "Ore zilnice" + Responses)
 * — Dacă vrei, poți păstra doar una din implementări și să redenumești alta,
 *   dar am lăsat-o așa ca să nu stric nimic existent.
 */

/*********************** ACTIVE & INCONSISTENTE ************************/

function _handleActive_(){
  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);
  var lastRow = sh.getLastRow();
  if (!headers.length || lastRow < 2){
    return jsonResp_({ ok:true, active:[] });
  }
  var cNm = _findCol(headers,['f_name','name','nume','angajat']);
  if (!cNm){
    return jsonResp_({ ok:false, error:'Nu găsesc coloana Nume.' });
  }
  var vals = sh.getRange(2,1,lastRow-1, sh.getLastColumn()).getValues();
  var namesByKey = {};
  for (var i=0;i<vals.length;i++){
    var nm = _norm(vals[i][cNm-1]);
    if (!nm) continue;
    var key = _normKeyName_(nm);
    if (!namesByKey[key]) namesByKey[key] = nm;
  }
  var activeList = [];
  for (var key in namesByKey){
    if (!namesByKey.hasOwnProperty(key)) continue;
    var nm = namesByKey[key];
    var stWrap = _computeStateForName_(nm);
    if (!stWrap || !stWrap.ok) continue;
    var st = stWrap.state;
    var normal = st.normal || {};
    var extra = st.extra || {};
    var isActive = (!!normal.running || !!normal.paused || !!extra.running);
    if (!isActive) continue;
    activeList.push({
      name: nm,
      dept: _getDeptForName_(nm),
      normalRunning: !!normal.running,
      normalPaused: !!normal.paused,
      extraRunning: !!extra.running,
      lastNormalStart: st.lastNormalStart || null,
      lastNormalFinish: st.lastNormalFinish || null,
      lastExtraStart: st.lastExtraStart || null,
      lastExtraFinish: st.lastExtraFinish || null
    });
  }
  activeList.sort(function(a,b){
    var d = (a.dept||'').localeCompare(b.dept||'', 'ro');
    if (d !== 0) return d;
    return a.name.localeCompare(b.name,'ro');
  });
  return jsonResp_({ ok:true, active: activeList });
}

/**
 * Endpoint generic pentru butoanele de rapoarte din dashboard.
 * exemplu:
 *   GET ...?fn=reports&type=daily
 *   GET ...?fn=reports&type=weekly
 *   GET ...?fn=reports&type=monthly
 *   GET ...?fn=reports&type=all
 *   GET ...?fn=reports&type=rebuild
 */
function _handleReports_(e){
  var params = (e && e.parameter) || {};
  var type = String(params.type || params.report || '').toLowerCase().trim();
  if (!type) type = 'all';

  var results = [];

  function safeRun(label, fn){
    try {
      var files = fn() || [];
      results.push({ label: label, ok: true, files: files });
    } catch (err) {
      Logger.log('Raport ' + label + ' a dat eroare: ' + err);
      results.push({ label: label, ok: false, error: String(err) });
    }
  }

  if (type === 'rebuild') {
    safeRun('rebuildAllReports', rebuildAllReports);
  } else {
    if (type === 'daily'   || type === 'all') safeRun('daily',   dailyReports);
    if (type === 'weekly'  || type === 'all') safeRun('weekly',  weeklyReports);
    if (type === 'monthly' || type === 'all') safeRun('monthly', monthlyReports);
  }

  if (!results.length){
    return jsonResp_({ ok:false, error:'Tip raport necunoscut: ' + type });
  }

  return jsonResp_({
    ok: true,
    type: type,
    results: results
  });
}

/*********************** doGet / doPost ************************/

function doGet(e){
  var fnRaw = (e && e.parameter && e.parameter.fn) ? String(e.parameter.fn) : '';
  var fn = fnRaw.split(/[?&]/)[0];

  if (fn === 'state'){
    var nameS = (e && e.parameter && e.parameter.name) ? String(e.parameter.name) : '';
    if (!nameS) return jsonResp_({ok:false, error:'Lipsește param name'});
    // status LIVE (nu folosim cache aici, ca să nu rămânem în urmă după butoane)
    return jsonResp_(_computeStateForName_(nameS, true));
  }
  if (fn === 'stats'){
    var nameT = (e && e.parameter && e.parameter.name) ? String(e.parameter.name) : '';
    if (!nameT) return jsonResp_({ok:false, error:'Lipsește param name'});
    var stats = _getTodayStats_(nameT);
    return jsonResp_({ ok:true, stats: stats });
  }
  if (fn === 'pausetotals'){
    var nameP = (e && e.parameter && e.parameter.name) ? String(e.parameter.name) : '';
    var untilIso = (e && e.parameter && e.parameter.until) ? String(e.parameter.until) : '';
    if (!nameP) return jsonResp_({ ok:false, error:'Lipsește param name' });
    var until = untilIso ? new Date(untilIso) : new Date();
    if (isNaN(until)) return jsonResp_({ ok:false, error:'Param until invalid' });
    var res = _pauseTotalsForDayUntil_(nameP, until);
    return jsonResp_(res);
  }

if (fn === 'adminEvents'){
  return _handleAdminEvents_(e);
}

// -------------------------
// MANAGERS MAP (admin) - JSONP
// -------------------------
if (fn === 'adminManagersMap'){
  return _handleAdminManagersMap_(e);
}
if (fn === 'adminSetManager'){
  return _handleAdminSetManager_(e);
}

    // -------------------------
  // FIX DAY (Editor zi) - V3 (JSONP safe, openById safe)
  // -------------------------
  if (fn === 'fixDayPing') {
    try{
      var ssP = _pontajSs_();
      var shP = _getResponsesSheet_(ssP);
      return jsonpResp_(e, { ok:true, ssTitle:ssP.getName(), sheet: shP.getName(), lastRow: shP.getLastRow(), lastCol: shP.getLastColumn() });
    }catch(err){
      return jsonpResp_(e, { ok:false, error: String(err && err.message ? err.message : err) });
    }
  }

  if (fn === 'fixDayGet') {
    var data = fixDayGetDataV3_(e);
    return jsonpResp_(e, data);
  }

  if (fn === 'fixDayApply') {
    var data2 = fixDayApplyFromPayloadV3_(e);
    return jsonpResp_(e, data2);
  }

  if (fn === 'fixDayApplyChunk') {
    var dataC = fixDayApplyChunkV3_(e);
    return jsonpResp_(e, dataC);
  }
  if (fn === 'fixDayApplyFinalize') {
    var dataF = fixDayApplyFinalizeV3_(e);
    return jsonpResp_(e, dataF);
  }




  if (fn === 'fixDay' || fn === 'fixday') return jsonResp_(fixDayGet_(e));
  if (fn === 'fixDayAudit') return _handleFixDayAudit_(e);

  if (fn === 'adminPresence') return jsonpResp_(e, adminPresence_(e));

  function handleAdminPresence_(e) {
  const ttlMin = Math.max(1, parseInt(e.parameter.ttlMin || "2", 10));
  
  // TODO: aici tu îți calculezi prezența
  // Exemplu payload (înlocuiește cu logica ta reală):
  const payload = {
    ok: true,
    serverTs: Date.now(),
    ttlMin,
    users: getPresenceUsers_(ttlMin) // <-- funcția ta reală
  };

  const cb = (e.parameter.callback || "").trim();

  // ✅ JSONP mode (pentru GitHub Pages)
  if (cb) {
    const js = `${cb}(${JSON.stringify(payload)});`;
    return ContentService
      .createTextOutput(js)
      .setMimeType(ContentService.MimeType.JAVASCRIPT);
  }

  // fallback JSON normal (pt debug)
  return ContentService
    .createTextOutput(JSON.stringify(payload))
    .setMimeType(ContentService.MimeType.JSON);
}


  if (fn === 'active'){
    return _handleActive_();
  }
  if (fn === 'adminPdf'){
    return _handleAdminPdf_(e);
  }
  if (fn === 'adminPdfDept'){
    return _handleAdminPdfDept_(e);
  }
  if (fn === 'adminPing'){
  return jsonpResp_(e, adminPing_(e.parameter || {}));
}
  if (fn === 'inconsistencies') {
    return _handleInconsistencies_();
  }
    // === NOU: endpoint-uri pentru butoanele de rapoarte din dashboard ===

  // 1) Endpoint direct per tip (simplu de folosit din frontend):
  if (fn === 'dailyReports') {
    try {
      var filesD = dailyReports() || [];
      return jsonResp_({
        ok:true,
        type:'daily',
        msg:'Raportul zilnic a fost generat.',
        files: filesD
      });
    } catch (err) {
      return jsonResp_({ ok:false, type:'daily', error:String(err) });
    }
  }

  if (fn === 'weeklyReports') {
    try {
      var filesW = weeklyReports() || [];
      return jsonResp_({
        ok:true,
        type:'weekly',
        msg:'Raportul săptămânal a fost generat.',
        files: filesW
      });
    } catch (err) {
      return jsonResp_({ ok:false, type:'weekly', error:String(err) });
    }
  }

  if (fn === 'monthlyReports') {
    try {
      var filesM = monthlyReports() || [];
      return jsonResp_({
        ok:true,
        type:'monthly',
        msg:'Rapoartele lunare au fost generate.',
        files: filesM
      });
    } catch (err) {
      return jsonResp_({ ok:false, type:'monthly', error:String(err) });
    }
  }

    if (fn === 'monthlyReportsLatest') {
    try {
      var filesML = monthlyReportsLatest() || [];
      return jsonResp_({
        ok: true,
        type: 'monthlyLatest',
        msg: 'Rapoartele lunare CURPINZÂND LUNA CURENTĂ până în acest moment au fost generate.',
        files: filesML
      });
    } catch (err) {
      return jsonResp_({
        ok: false,
        type: 'monthlyLatest',
        error: String(err)
      });
    }
  }

  if (fn === 'rebuildReports' || fn === 'rebuildAllReports') {
    try {
      rebuildAllReports();
      return jsonResp_({
        ok:true,
        type:'rebuild',
        msg:'Toate foile de statistici au fost regenerate.',
        files:[]
      });
    } catch (err) {
      return jsonResp_({ ok:false, type:'rebuild', error:String(err) });
    }
  }


  // 2) Endpoint generic: ?fn=reports&type=daily|weekly|monthly|all|rebuild
  if (fn === 'reports') {
    return _handleReports_(e);
  }

  return ContentService.createTextOutput('Servelect Web App activ').setMimeType(ContentService.MimeType.TEXT);
}

function doPost(e) {
  var data = {};
  try {
    data = JSON.parse((e && e.postData && e.postData.contents) ? e.postData.contents : "{}");
  } catch (err) {
    data = {};
  }

  var fn = (e && e.parameter && e.parameter.fn) ? String(e.parameter.fn) : "";
  fn = fn.split(/[?&]/)[0];

  // ✅ fallback: dacă nu vine fn în query, îl luăm din body
  if (!fn && data && data.fn) {
    fn = String(data.fn || '').trim();
    fn = fn.split(/[?&]/)[0];
  }

  // ✅ IMPORTANT: aici era problema ta -> aveai "catch" fără "try"
  try {

    // ADMIN LIVE (heartbeat + list)
    if (fn === "adminPing") {
      return jsonResp_(adminPing_(data));
    }

    // ✅ adminPresence_ așteaptă e.parameter, deci la POST îl împachetăm
    if (fn === "adminPresence") {
      return jsonResp_(adminPresence_({ parameter: data }));
    }

    if (fn === 'guard'){
      var nameG = _norm(data.name||'');
      var action = _normAction(data.action);
      if (!nameG) return jsonResp_({ok:false, msg:'Lipsește name'});
      if (!action) return jsonResp_({ok:false, msg:'Lipsește action'});

      // Anti dublu-click: dacă aceeași acțiune vine foarte repede, o blocăm direct
      var recent = _getGuardRecent_(nameG);
      var nowMs = new Date().getTime();
      if (recent && recent.action === action && (nowMs - (recent.ts || 0)) < 4000){
        return jsonResp_({ok:false, msg:'Aceeași acțiune a fost deja trimisă. Așteaptă câteva secunde.'});
      }

      // Pentru gard folosim STARE LIVE (fără cache de 60s)
      var st = _computeStateForName_(nameG, true);
      if (!st.ok) return jsonResp_({ok:false, msg:'Nu pot obține starea.'});
      var g = _guardAction_(st.state, action);

      if (g.ok){
        _setGuardRecent_(nameG, {action: action, ts: nowMs});
      }
      return jsonResp_(g);
    }

      // -------------------------
  // FIX DAY (Editor zi) - POST (optional)
  // -------------------------
  if (fn === 'fixDayApply') {
    var data;
    try { data = JSON.parse(e.postData.contents || '{}'); } catch (err) { data = {}; }
    return jsonResp_(_handleFixDayApply_(data, e));
  }


    if (fn === 'fixDayApply') return jsonResp_(fixDayApply_(body, e));
    if (fn === 'fixDayApply') return _handleFixDayApply_(data);

    // === leave (implicit) ===
    var name = String(data.name || '').trim();
    var activityType = String(data.activityType || '').trim().toLowerCase();
    var startDateStr = String(data.startDate || '').trim();
    var endDateStr   = String(data.endDate   || '').trim();
    var personalEmail = String(data.personalEmail || '').trim();
    var notes = String(data.notes || '').trim();
    var days = data.days;

    if (!name) return jsonResp_({ok:false, error:'Lipsește numele'});
    if (!LEAVE_TYPES[activityType]) return jsonResp_({ok:false, error:'Tip concediu nevalid'});
    if (!personalEmail || !/.+@.+\..+/.test(personalEmail)) return jsonResp_({ok:false, error:'Email personal invalid'});

    var daysList = [];
    if (days && Object.prototype.toString.call(days) === '[object Array]') {
      for (var i=0;i<days.length;i++){
        var dstr = String(days[i] || '').trim();
        if (!dstr) continue; var d = new Date(dstr); if (!isNaN(d)) daysList.push(d);
      }
    } else if (typeof days === 'string' && days.trim()) {
      days.split(/[,;\s]+/).forEach(function(dstr){
        dstr = String(dstr || '').trim(); if (!dstr) return; var d = new Date(dstr); if (!isNaN(d)) daysList.push(d);
      });
    }

    var startDate, endDate, zile = 0, zileTxt = '';
    if (daysList.length) {
      daysList.sort(function(a,b){ return a - b; });
      startDate = new Date(daysList[0]);
      endDate   = new Date(daysList[daysList.length - 1]);
      zile = daysList.length;
      var tz = TZ_RO;
      zileTxt = daysList.map(function(d){ return Utilities.formatDate(d, tz, 'yyyy-MM-dd'); }).join(', ');
    } else {
      if (!startDateStr || !endDateStr) return jsonResp_({ok:false, error:'Lipsesc datele (zile individuale sau interval)'});
      startDate = new Date(startDateStr);
      endDate   = new Date(endDateStr);
      if (isNaN(startDate) || isNaN(endDate)) return jsonResp_({ok:false, error:'Date invalide'});
      if (endDate < startDate) return jsonResp_({ok:false, error:'Sfârșitul < început'});
      zile = Math.floor((endDate - startDate)/(1000*60*60*24)) + 1;
      var tz2 = TZ_RO;
      zileTxt = Utilities.formatDate(startDate, tz2, 'yyyy-MM-dd') + '…' + Utilities.formatDate(endDate, tz2, 'yyyy-MM-dd');
    }

    var sh = ensureConcediiSheet_();
    sh.appendRow([ new Date(), name, activityType, startDate, endDate, zile, personalEmail, notes, 'În așteptare', zileTxt ]);
    var row = sh.getLastRow();

    var subject = 'Cerere concediu - ' + name + ' (' + zile + ' zile)';
    var body =
      'A fost trimisă o nouă cerere de concediu:\n\n' +
      'Angajat: ' + name + '\n' +
      'Tip concediu: ' + activityType + '\n' +
      (daysList.length ? ('Zile: ' + zileTxt + '\n') : ('Interval: ' + startDate.toDateString() + ' - ' + endDate.toDateString() + ' (' + zile + ' zile)\n')) +
      'Email personal: ' + personalEmail + '\n' +
      'Notă: ' + (notes || '(niciuna)') + '\n\n' +
      '---\nAcest mesaj a fost generat automat.';

    try {
      safeSendEmail({ to: HR_TO, subject: subject, body: body, replyTo: personalEmail, name: name + ' (Servelect Pontaj)' });
      safeSendEmail({ to: personalEmail, subject: '[Copie] ' + subject, body: body, name: 'Servelect Pontaj' });
      sh.getRange(row, 9).setValue('Trimis ✓');
    } catch (sendErr) {
      sh.getRange(row, 9).setValue('Eroare: ' + String(sendErr));
    }
    return jsonResp_({ ok:true, zile:zile, sentTo: HR_TO });

  } catch (err) {
    return jsonResp_({ ok:false, error: String(err) });
  }
}

/*********************** DIAGNOSTIC ************************/

function showExecutionContext() {
  var user = Session.getActiveUser().getEmail();
  var tz = TZ_RO;
  var root = _getReportsRoot_();
  Logger.log('Execută ca: ' + user);
  Logger.log('Time zone: ' + tz);
  Logger.log('Folder rădăcină rapoarte: ' + root.getName() + ' | URL: ' + root.getUrl());
}
function smokeDrive() {
  var root = _getReportsRoot_();
  var testFolder = _ensureFolder_(root, 'TEST_Pontaj');
  var f = testFolder.createFile('hello.txt', 'ok ' + new Date());
  Logger.log('Am scris: ' + f.getName() + ' | URL: ' + f.getUrl());
}
function forceDailyNow() { dailyReports(); Logger.log('dailyReports() rulat.'); }
function forceWeeklyNow(){ weeklyReports(); Logger.log('weeklyReports() rulat.'); }
function forceMonthlyNow(){ monthlyReports(); Logger.log('monthlyReports() rulat.'); }

function diagPontaj(){
  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);
  Logger.log('Sheet răspunsuri: ' + sh.getName());
  Logger.log('Antete: ' + JSON.stringify(headers));
  function col(keys){ return _findCol(headers, keys); }
  var cTs  = headers.indexOf('Timestamp')+1 || col(['f_timestamp','timestamp','data','ora']);
  var cNm  = col(['f_name','name','nume','angajat']);
  var cAc  = col(['f_action','action','actiune','acțiune']);
  var cDur = col(['durata (ore)','duration(h)','durata']);
  Logger.log('cTs=' + cTs + ', cNm=' + cNm + ', cAc=' + cAc + ', cDur=' + cDur);
  Logger.log('Rows răspunsuri (fără header): ' + Math.max(0, sh.getLastRow()-1));
  rebuildAllReports();
  var dz = ss.getSheetByName('Ore zilnice');
  var ot = ss.getSheetByName('Ore suplimentare');
  var ex = ss.getSheetByName('Ore extra');
  var ml = ss.getSheetByName('Total lunar');
  Logger.log('Ore zilnice rows: ' + (dz ? dz.getLastRow() : 0));
  Logger.log('Ore suplimentare rows: ' + (ot ? ot.getLastRow() : 0));
  Logger.log('Ore extra rows: ' + (ex ? ex.getLastRow() : 0));
  Logger.log('Total lunar rows: ' + (ml ? ml.getLastRow() : 0));
}

/**
 * diagInconsistencies()
 */
function diagInconsistencies(){
  var ss = SpreadsheetApp.getActive();
  var sh = _getResponsesSheet_(ss);
  var headers = _getHeaders(sh);
  var cTs  = headers.indexOf('Timestamp')+1 || _findCol(headers,['f_timestamp','timestamp','data','ora']);
  var cNm  = _findCol(headers,['f_name','name','nume','angajat']);
  var cAc  = _findCol(headers,['f_action','action','actiune','acțiune']);
  if (!cTs || !cNm || !cAc){
    Logger.log('diagInconsistencies: lipsesc coloanele esentiale (Timestamp/Nume/Acțiune).');
    return;
  }
  var last = sh.getLastRow();
  if (last < 2){
    Logger.log('diagInconsistencies: foaia nu are date.');
    return;
  }
  var vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();
  var events = [];
  for (var i=0;i<vals.length;i++){
    var nm = _norm(vals[i][cNm-1]); if (!nm) continue;
    var ts = _toDate(vals[i][cTs-1]); if (!ts) continue;
    var ac = _normAction(vals[i][cAc-1]);
    if (!ac) continue;
    events.push({
      row: i+2,
      name: nm,
      nameKey: _normKeyName_(nm),
      ts: ts,
      action: ac
    });
  }
  if (!events.length){
    Logger.log('diagInconsistencies: nu exista evenimente.');
    return;
  }
  events.sort(function(a,b){
    var nk = a.nameKey.localeCompare(b.nameKey, 'ro');
    if (nk !== 0) return nk;
    var t = a.ts - b.ts; if (t !== 0) return t;
    return a.row - b.row;
  });

  function makeIssue(ev, type, detail){
    return {
      name: ev.name,
      ts: ev.ts,
      action: ev.action,
      type: type,
      detail: detail,
      row: ev.row
    };
  }

  var issues = [];
  var currentNameKey = null;
  var openNorm = false;
  var openExtra = false;
  var paused = false;

  for (var idx=0; idx<events.length; idx++){
    var ev = events[idx];
    if (ev.nameKey !== currentNameKey){
      currentNameKey = ev.nameKey;
      openNorm = false;
      openExtra = false;
      paused = false;
    }
    var ac = ev.action;
    if (ac === 'start'){
      if (openNorm){
        issues.push(makeIssue(ev,'START consecutiv','Există deja un interval START neînchis (fără FINISH).'));
      }
      openNorm = true;
    } else if (ac === 'finish'){
      if (!openNorm){
        issues.push(makeIssue(ev,'FINISH fără START','Nu există un START anterior neînchis.'));
      }
      if (paused){
        issues.push(makeIssue(ev,'FINISH în PAUSE','Era în PAUSE în momentul FINISH-ului.'));
        paused = false;
      }
      openNorm = false;
    } else if (ac === 'pause'){
      if (!openNorm){
        issues.push(makeIssue(ev,'PAUSE fără START','Nu există START activ pentru acest PAUSE.'));
      }
      if (paused){
        issues.push(makeIssue(ev,'PAUSE dublu','Există deja o pauză deschisă (lipsă UNPAUSE).'));
      }
      paused = true;
    } else if (ac === 'unpause'){
      if (!openNorm){
        issues.push(makeIssue(ev,'UNPAUSE fără START','Nu există START activ pentru acest UNPAUSE.'));
      }
      if (!paused){
        issues.push(makeIssue(ev,'UNPAUSE fără PAUSE','Nu există un PAUSE anterior deschis.'));
      }
      paused = false;
    } else if (ac === 'extra_start'){
      if (openExtra){
        issues.push(makeIssue(ev,'EXTRA_START consecutiv','Există deja EXTRA_START neînchis (fără EXTRA_FINISH).'));
      }
      openExtra = true;
    } else if (ac === 'extra_finish'){
      if (!openExtra){
        issues.push(makeIssue(ev,'EXTRA_FINISH fără EXTRA_START','Nu există EXTRA_START anterior neînchis.'));
      }
      openExtra = false;
    }
  }

  var sheetIssues = ss.getSheetByName('Inconsistente') || ss.insertSheet('Inconsistente');
  sheetIssues.clearContents();
  sheetIssues.appendRow(['Nume','Timestamp','Acțiune','Tip problemă','Detalii','Row Responses']);
  var tz = TZ_RO;
  if (issues.length){
    var rowsOut = [];
    for (var j=0;j<issues.length;j++){
      var it = issues[j];
      rowsOut.push([
        it.name,
        Utilities.formatDate(it.ts, tz, 'yyyy-MM-dd HH:mm:ss'),
        it.action,
        it.type,
        it.detail,
        it.row
      ]);
    }
    sheetIssues.getRange(2,1, rowsOut.length, rowsOut[0].length).setValues(rowsOut);
  }
  sheetIssues.autoResizeColumns(1,6);
  Logger.log('diagInconsistencies: ' + issues.length + ' probleme găsite.');
}

function _handleInconsistencies_() {
  var ss = SpreadsheetApp.getActive();
  try {
    diagInconsistencies();
  } catch (err) {
    Logger.log('Eroare diagInconsistencies: ' + err);
  }

  var sh = ss.getSheetByName('Inconsistente');
  if (!sh || sh.getLastRow() < 2) {
    return jsonResp_({ ok: true, issues: [] });
  }

  var last = sh.getLastRow();
  var vals = sh.getRange(2, 1, last - 1, 6).getValues();
  var tz = TZ_RO;

  var issues = vals.map(function (row) {
    return {
      name: row[0] || '',
      ts: row[1] ? Utilities.formatDate(new Date(row[1]), tz, 'yyyy-MM-dd HH:mm:ss') : '',
      action: row[2] || '',
      type: row[3] || '',
      detail: row[4] || '',
      responsesRow: row[5] || null
    };
  });

  return jsonResp_({
    ok: true,
    issues: issues
  });
}

function diagMonthly(){
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName('Total lunar');
  if(!sh){ Logger.log('Lipsă foaie "Total lunar"'); return; }
  var headers = _getHeaders(sh);
  var cMonth = _findCol(headers, ['luna','month']);
  var cNm = _findCol(headers, ['nume','name','angajat']);
  if(!cMonth || !cNm){ Logger.log('Lipsesc coloanele Luna/Nume'); return; }

  var tz = TZ_RO;
  var now = new Date();
  var year = now.getFullYear();
  var mIndex = now.getMonth() - 1; if (mIndex < 0){ year--; mIndex = 11; }
  var targetYM = year + '-' + ('0'+(mIndex+1)).slice(-2);
  Logger.log('Target YM: ' + targetYM);

  var vals = sh.getRange(2,1, Math.max(0, sh.getLastRow()-1), sh.getLastColumn()).getValues();
  var found = {};
  for (var i=0;i<vals.length;i++){
    var ymCell = vals[i][cMonth-1];
    var ym = (Object.prototype.toString.call(ymCell)==='[object Date]') ? Utilities.formatDate(ymCell, tz, 'yyyy-MM') : _norm(ymCell);
    if (ym) found[ym] = 1;
  }
  Logger.log('Luni găsite în "Total lunar": ' + Object.keys(found).sort().join(', '));
}

function ensureFormSubmitTrigger(){
  var ssId = SpreadsheetApp.getActive().getId();
  var has = ScriptApp.getProjectTriggers().some(function(t){
    return t.getTriggerSourceId() === ssId && t.getEventType() === ScriptApp.EventType.ON_FORM_SUBMIT;
  });
  if (!has){
    ScriptApp.newTrigger('onFormSubmit')
      .forSpreadsheet(ssId)
      .onFormSubmit()
      .create();
  }
  Logger.log('Trigger onFormSubmit: ' + (has ? 'DEJA EXISTĂ' : 'CREAT'));
}

/*********************** TRIGGERE (OPȚIONAL) ************************/
function createTimeTriggers(){
  ScriptApp.newTrigger('rebuildAllReports').timeBased().everyDays(1).atHour(0).nearMinute(30).create();
  ScriptApp.newTrigger('dailyReports').timeBased().everyDays(1).atHour(1).nearMinute(0).create();
  ScriptApp.newTrigger('weeklyReports').timeBased().onWeekDay(ScriptApp.WeekDay.MONDAY).atHour(7).create();
  ScriptApp.newTrigger('monthlyReports').timeBased().onMonthDay(1).atHour(8).create();
}
// ===== EOF =====

/* ======================== ADMIN PRESENCE (cine e online) ======================== */

var ADMIN_PRESENCE_PROP_KEY = 'ADMIN_PRESENCE_V1';

function adminPresenceRead_() {
  const sp = PropertiesService.getScriptProperties();
  const raw = sp.getProperty(ADMIN_PRESENCE_PROP_KEY) || '{}';
  try { return JSON.parse(raw) || {}; } catch (e) { return {}; }
}

function adminPresenceWrite_(map) {
  const sp = PropertiesService.getScriptProperties();
  sp.setProperty(ADMIN_PRESENCE_PROP_KEY, JSON.stringify(map || {}));
}

/**
 * Ping de la admin (heartbeat)
 * body: { id, label, ua }
 */
function adminPing_(data) {
  data = data || {};
  const id = String(data.id || "").trim().toLowerCase();
  const label = String(data.label || id).trim();

  if (!id) return { ok:false, error:"Missing id" };

  const now = Date.now();

  const map = adminPresenceRead_() || {};
  map[id] = {
    id,
    label,
    lastSeenMs: now,
    ua: String(data.ua || ""),
    v: 2
  };

  adminPresenceWrite_(map);

  return { ok:true, id, now };
}


function adminPresence_(e) {
  const p = (e && e.parameter) || {};
  const ttlMin = Math.max(1, parseInt(p.ttlMin || "10", 10));
  const onlineSec = Math.max(5, parseInt(p.onlineSec || "45", 10));

  const now = Date.now();
  let map = adminPresenceRead_() || {};
  let changed = false;

  const list = [];

  for (const [id, rec] of Object.entries(map)) {
    const lastMs = pickLastSeenMs_(rec);
    const ageSec = lastMs ? Math.floor((now - lastMs) / 1000) : 999999;

    // cleanup
    if (ageSec > ttlMin * 60) {
      delete map[id];
      changed = true;
      continue;
    }

    list.push({
      id,
      label: (rec && rec.label) ? rec.label : id,
      ageSec,
      online: ageSec <= onlineSec
    });
  }

  if (changed) adminPresenceWrite_(map);

  list.sort((a, b) => a.ageSec - b.ageSec);

  return {
    ok: true,
    now,
    ttlMin,
    onlineSec,
    list
  };
}

// ✅ suport și pentru format vechi (ISO string / ts etc)
function pickLastSeenMs_(rec) {
  if (!rec) return 0;

  if (Number.isFinite(rec.lastSeenMs)) return rec.lastSeenMs;
  if (Number.isFinite(rec.ts)) return rec.ts;                 // legacy
  if (Number.isFinite(rec.lastSeen)) return rec.lastSeen;     // legacy numeric

  if (typeof rec.lastSeen === "string") {                     // legacy ISO
    const ms = Date.parse(rec.lastSeen);
    return Number.isFinite(ms) ? ms : 0;
  }

  return 0;
}


/* (opțional) curățare intrări vechi - dacă vrei, poți rula periodic */
function adminPresenceCleanup_() {
  const map = adminPresenceRead_();
  const nowMs = Date.now();

  const MAX_AGE_SEC = 7 * 24 * 3600;

  let changed = false;
  Object.keys(map).forEach(id => {
    const rec = map[id] || {};
    const t = pickLastSeenMs_(rec);
    if (!t) return;
    const ageSec = Math.floor((nowMs - t) / 1000);
    if (ageSec > MAX_AGE_SEC) {
      delete map[id];
      changed = true;
    }
  });

  if (changed) adminPresenceWrite_(map);
  return { ok: true, removedOld: changed };
}

/*********************** FIX DAY (Editor zi) ************************/

function fixDayGet_(e){
  try{
    var p = (e && e.parameter) ? e.parameter : {};
    var name = _norm(p.name || p.employee || '');
    var dateStr = _norm(p.date || '');
    if (!name) return { ok:false, error:'Lipsește parametrul name' };
    if (!dateStr) return { ok:false, error:'Lipsește parametrul date (YYYY-MM-DD)' };

    var sh = _getResponsesSheet_();
    var headers = _getHeaders(sh);

    var tsCol = _findCol(headers, ['Marcaj de timp','timestamp','time','date']);
    var nameCol = _findCol(headers, ['Nume','name','angajat']);
    var actionCol = _findCol(headers, ['Acțiune','actiune','action']);
    var notesCol = _findCol(headers, ['Note','notes','observatii','observații','comentarii','comment']);

    if (!tsCol || !nameCol || !actionCol){
      return { ok:false, error:'Nu am găsit coloanele obligatorii (Marcaj de timp / Nume / Acțiune) în sheet.' };
    }

    var lastRow = sh.getLastRow();
    if (lastRow < 2){
      return { ok:true, events:[], analysis:fixDayAnalyze_([]), audit:[], sheet:{ name: sh.getName() } };
    }

    var lastCol = sh.getLastColumn();
    var values = sh.getRange(2, 1, lastRow-1, lastCol).getValues();

    var nameKey = _normKeyName_(name);
    var events = [];

    for (var i=0; i<values.length; i++){
      var rowIndex = i + 2;
      var row = values[i];

      var rowName = row[nameCol-1];
      if (!_samePerson(rowName, name)) continue;

      var ts = _toDate(row[tsCol-1]);
      if (!ts) continue;

      var day = Utilities.formatDate(ts, TZ_RO, 'yyyy-MM-dd');
      if (day !== dateStr) continue;

      var rawAction = row[actionCol-1];
      var actionN = fixDaySafeAction_(_normAction(rawAction));

      events.push({
        row: rowIndex,
        timestamp: ts.toISOString(),
        localTime: Utilities.formatDate(ts, TZ_RO, 'HH:mm'),
        action: actionN,
        rawAction: String(rawAction == null ? '' : rawAction),
        notes: notesCol ? String(row[notesCol-1] == null ? '' : row[notesCol-1]) : ''
      });
    }

    events.sort(function(a,b){
      if (a.timestamp < b.timestamp) return -1;
      if (a.timestamp > b.timestamp) return 1;
      return a.row - b.row;
    });

    var analysis = fixDayAnalyze_(events);
    var audit = fixDayReadAudit_(nameKey, dateStr, 150);

    return {
      ok:true,
      events: events,
      analysis: analysis,
      audit: audit,
      sheet: {
        name: sh.getName(),
        tsCol: tsCol,
        nameCol: nameCol,
        actionCol: actionCol,
        notesCol: notesCol
      }
    };

  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }
}

function fixDayApply_(body, e){
  var lock = LockService.getScriptLock();
  lock.waitLock(15000);

  try{
    body = body || {};
    var name = _norm(body.name || body.employee || '');
    var dateStr = _norm(body.date || '');
    var ops = body.ops || [];
    var adminEmail = _norm(body.adminEmail || body.admin || '');
    var userAgent = (e && e.parameter && e.parameter.ua) ? _norm(e.parameter.ua) : '';

    if (!name) return { ok:false, error:'Lipsește name' };
    if (!dateStr) return { ok:false, error:'Lipsește date (YYYY-MM-DD)' };
    if (!ops || !ops.length) return { ok:false, error:'Nu există ops' };

    // optional hard-guard: dacă ai setat Script Properties -> ADMIN_KEY, verifică-l
    var requiredKey = PropertiesService.getScriptProperties().getProperty('ADMIN_KEY');
    if (requiredKey){
      var providedKey = _norm(body.adminKey || body.key || '');
      if (!providedKey || providedKey !== requiredKey){
        return { ok:false, error:'ADMIN_KEY invalid' };
      }
    }

    var sh = _getResponsesSheet_();
    var headers = _getHeaders(sh);

    var tsCol = _findCol(headers, ['Marcaj de timp','timestamp','time','date']);
    var nameCol = _findCol(headers, ['Nume','name','angajat']);
    var actionCol = _findCol(headers, ['Acțiune','actiune','action']);
    var notesCol = _findCol(headers, ['Note','notes','observatii','observații','comentarii','comment']);

    if (!tsCol || !nameCol || !actionCol){
      return { ok:false, error:'Nu am găsit coloanele obligatorii (Marcaj de timp / Nume / Acțiune) în sheet.' };
    }

    var auditSh = fixDayEnsureAuditSheet_();

    // parse YYYY-MM-DD
    var parts = dateStr.split('-').map(function(x){ return parseInt(x,10); });
    if (parts.length !== 3 || !parts[0] || !parts[1] || !parts[2]){
      return { ok:false, error:'Date invalid (aștept YYYY-MM-DD)' };
    }
    var y = parts[0], m = parts[1], d = parts[2];

    var changed = 0;

    for (var i=0; i<ops.length; i++){
      var op = ops[i] || {};
      var rowIndex = parseInt(op.row,10);
      if (!rowIndex || rowIndex < 2) continue;

      // verificăm că rândul aparține persoanei (minim)
      var rowName = sh.getRange(rowIndex, nameCol).getValue();
      if (!_samePerson(rowName, name)){
        continue; // nu modificăm alt om
      }

      var beforeTs = _toDate(sh.getRange(rowIndex, tsCol).getValue());
      if (!beforeTs) continue;

      var beforeDay = Utilities.formatDate(beforeTs, TZ_RO, 'yyyy-MM-dd');
      if (beforeDay !== dateStr){
        continue; // nu modificăm altă zi
      }

      var beforeActionRaw = sh.getRange(rowIndex, actionCol).getValue();
      var beforeNotes = notesCol ? sh.getRange(rowIndex, notesCol).getValue() : '';

      var newAction = fixDaySafeAction_(_normAction(op.action || op.newAction || beforeActionRaw));
      var newTime = _norm(op.time || op.hhmm || op.newTime || '');

      // dacă nu vine timp, păstrăm timpul existent
      var hhmm = newTime || Utilities.formatDate(beforeTs, TZ_RO, 'HH:mm');
      var tParts = hhmm.split(':');
      if (tParts.length !== 2) continue;
      var hh = parseInt(tParts[0],10), mm = parseInt(tParts[1],10);
      if (isNaN(hh) || isNaN(mm) || hh < 0 || hh > 23 || mm < 0 || mm > 59) continue;

      var newTs = new Date(y, m-1, d, hh, mm, 0);
      var newNotes = (typeof op.notes !== 'undefined') ? String(op.notes) : (notesCol ? String(beforeNotes == null ? '' : beforeNotes) : '');

      var beforeObj = {
        ts: beforeTs ? beforeTs.toISOString() : null,
        action: String(beforeActionRaw == null ? '' : beforeActionRaw),
        notes: String(beforeNotes == null ? '' : beforeNotes)
      };
      var afterObj = {
        ts: newTs.toISOString(),
        action: newAction,
        notes: newNotes
      };

      // apply
      sh.getRange(rowIndex, tsCol).setValue(newTs);
      sh.getRange(rowIndex, actionCol).setValue(newAction);
      if (notesCol) sh.getRange(rowIndex, notesCol).setValue(newNotes);

      // audit
      auditSh.appendRow([
        new Date(),
        adminEmail || 'admin',
        name,
        dateStr,
        rowIndex,
        JSON.stringify(op),
        JSON.stringify(beforeObj),
        JSON.stringify(afterObj),
        userAgent
      ]);

      changed++;
    }

    return { ok:true, changedCount: changed };

  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }finally{
    lock.releaseLock();
  }
}

function fixDayAnalyze_(events){
  var issues = [];
  var started = false, paused = false, extraStarted = false;

  function pushIssue(type, message, row){
    issues.push({ type:type, message:message, row: row || null });
  }

  for (var i=0; i<events.length; i++){
    var ev = events[i];
    var a = _normAction(ev.action);

    if (a === 'start'){
      if (started) pushIssue('double_start', 'Start de două ori fără Finish între ele.', ev.row);
      started = true; paused = false;
    }
    else if (a === 'pause'){
      if (!started) pushIssue('pause_without_start', 'Pause fără Start înainte.', ev.row);
      if (paused) pushIssue('double_pause', 'Pause de două ori (fără Unpause).', ev.row);
      paused = true;
    }
    else if (a === 'unpause'){
      if (!started) pushIssue('unpause_without_start', 'Unpause fără Start înainte.', ev.row);
      if (!paused) pushIssue('unpause_without_pause', 'Unpause fără Pause înainte.', ev.row);
      paused = false;
    }
    else if (a === 'finish'){
      if (!started) pushIssue('finish_without_start', 'Finish fără Start înainte.', ev.row);
      if (paused) pushIssue('finish_while_paused', 'Finish în timp ce era Pause (lipsește Unpause?).', ev.row);
      started = false; paused = false;
    }
    else if (a === 'extra_start'){
      if (extraStarted) pushIssue('double_extra_start', 'Extra Start de două ori (lipsește Extra Finish).', ev.row);
      extraStarted = true;
    }
    else if (a === 'extra_finish'){
      if (!extraStarted) pushIssue('extra_finish_without_start', 'Extra Finish fără Extra Start.', ev.row);
      extraStarted = false;
    }
    else {
      // acțiune necunoscută / goală
      pushIssue('unknown_action', 'Acțiune necunoscută: ' + ev.action, ev.row);
    }
  }

  if (started) pushIssue('missing_finish', 'Zi “ruptă”: există Start fără Finish.', null);
  if (paused) pushIssue('missing_unpause', 'Zi “ruptă”: există Pause fără Unpause.', null);
  if (extraStarted) pushIssue('missing_extra_finish', 'Zi “ruptă”: există Extra Start fără Extra Finish.', null);

  return {
    ok:true,
    count: issues.length,
    issues: issues
  };
}

function fixDayEnsureAuditSheet_(){
  var ss = SpreadsheetApp.getActiveSpreadsheet();
  var name = 'FixDay Audit';
  var sh = ss.getSheetByName(name);
  if (!sh){
    sh = ss.insertSheet(name);
    sh.appendRow(['Timestamp','Admin','Employee','Date','Row','Op','Before','After','UserAgent']);
    sh.setFrozenRows(1);
  }
  return sh;
}

function fixDayReadAudit_(nameKey, dateStr, limit){
  try{
    var ss = SpreadsheetApp.getActiveSpreadsheet();
    var sh = ss.getSheetByName('FixDay Audit');
    if (!sh) return [];

    var lastRow = sh.getLastRow();
    if (lastRow < 2) return [];

    var lastCol = sh.getLastColumn();
    var startRow = Math.max(2, lastRow - (limit || 150) + 1);
    var values = sh.getRange(startRow, 1, lastRow - startRow + 1, lastCol).getValues();

    var out = [];
    for (var i=values.length-1; i>=0; i--){
      var r = values[i];
      var employee = _norm(r[2]);
      var date = _norm(r[3]);
      if (_normKeyName_(employee) !== nameKey) continue;
      if (date !== dateStr) continue;

      var ts = _toDate(r[0]);
      out.push({
        at: ts ? ts.toISOString() : '',
        admin: String(r[1] || ''),
        employee: employee,
        date: date,
        row: r[4],
        op: String(r[5] || ''),
        before: String(r[6] || ''),
        after: String(r[7] || '')
      });
    }
    return out;
  }catch(err){
    return [];
  }
}

function fixDaySafeAction_(a){
  a = _normAction(a);
  var ok = {
    start:1,
    pause:1,
    unpause:1,
    finish:1,
    extra_start:1,
    extra_finish:1,
    void:1
  };
  if (ok[a]) return a;
  // fallback: dacă e gol, nu strică
  if (!a) return 'start';
  return a;
}

// ==============================
// FIX DAY (Editor de zi) + AUDIT
// ==============================
//
// GET  ?fn=fixDay&name=...&date=YYYY-MM-DD
// GET  ?fn=fixDayAudit&name=...&date=YYYY-MM-DD&limit=50
// POST { fn:'fixDayApply', name, date, admin:{...}, ops:[ ... ] }
//
// ops:
//  - { type:'update', row: <nr>, timestampIso:'YYYY-MM-DDTHH:mm:ss', action:'Start|Pause|...', notes:'...' }
//  - { type:'void',   row: <nr>, notes:'...' }
//  - { type:'insert', timestampIso:'YYYY-MM-DDTHH:mm:ss', action:'Start|...', notes:'...' }

function _fixDayFindCols_(headers) {
  var cTs = _findCol(headers, ['Marcaj de timp','Timestamp','Data','Data/Ora','Date/Time']);
  var cName = _findCol(headers, ['Nume','Name','Employee','Angajat']);
  var cAction = _findCol(headers, ['Acțiune','Actiune','Action','Eveniment']);
  var cNotes = _findCol(headers, ['Note','Notite','Observatii','Observații','Notes']);
  return { cTs:cTs, cName:cName, cAction:cAction, cNotes:cNotes };
}

function _fixDayAuditSheet_() {
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName('FixDay_Audit');
  if (!sh) {
    sh = ss.insertSheet('FixDay_Audit');
    sh.appendRow([
      'AuditTimestamp',
      'AdminEmail',
      'EmployeeName',
      'Date',
      'OpType',
      'TargetRow',
      'Before',
      'After',
      'Comment'
    ]);
  }
  return sh;
}

function _fixDayAppendAudit_(adminEmail, employeeName, dateYMD, opType, targetRow, beforeObj, afterObj, comment) {
  var sh = _fixDayAuditSheet_();
  sh.appendRow([
    new Date(),
    adminEmail || '',
    employeeName || '',
    dateYMD || '',
    opType || '',
    targetRow || '',
    JSON.stringify(beforeObj || {}),
    JSON.stringify(afterObj || {}),
    comment || ''
  ]);
}

function _handleFixDayGet_(e) {
  try {
    var name = String((e.parameter && e.parameter.name) || '').trim();
    var date = String((e.parameter && e.parameter.date) || '').trim(); // YYYY-MM-DD

    if (!name) return jsonResp_({ ok:false, error:'Missing name' });
    if (!date) return jsonResp_({ ok:false, error:'Missing date' });

    var sh = _getResponsesSheet_();
    var headers = _getHeaders(sh);
    var cols = _fixDayFindCols_(headers);

    if (!cols.cTs || !cols.cName || !cols.cAction) {
      return jsonResp_({ ok:false, error:'Nu găsesc coloanele: Timestamp / Nume / Acțiune în sheet-ul de răspunsuri.' });
    }

    var lastRow = sh.getLastRow();
    var lastCol = sh.getLastColumn();
    if (lastRow < 2) return jsonResp_({ ok:true, events:[] });

    var values = sh.getRange(2, 1, lastRow - 1, lastCol).getValues();

    var targetNameN = _norm(name);
    var events = [];

    for (var i = 0; i < values.length; i++) {
      var row = values[i];
      var ts = row[cols.cTs - 1];
      var emp = row[cols.cName - 1];
      var action = row[cols.cAction - 1];
      var notes = cols.cNotes ? row[cols.cNotes - 1] : '';

      if (!emp) continue;
      if (_norm(String(emp)) !== targetNameN) continue;
      if (!(ts instanceof Date)) {
        // dacă e string, încercăm parse simplu
        var t2 = new Date(ts);
        if (isNaN(t2.getTime())) continue;
        ts = t2;
      }

      // Filtrare pe zi în TZ Europe/Bucharest
      var ymd = Utilities.formatDate(ts, TZ_RO, 'yyyy-MM-dd');
      if (ymd !== date) continue;

      events.push({
        row: i + 2, // index real în sheet
        time: Utilities.formatDate(ts, TZ_RO, 'HH:mm:ss'),
        timestampIso: Utilities.formatDate(ts, TZ_RO, "yyyy-MM-dd'T'HH:mm:ss"),
        action: String(action || ''),
        notes: String(notes || '')
      });
    }

    // sort cronologic
    events.sort(function(a,b){
      return a.time.localeCompare(b.time);
    });

    return jsonResp_({ ok:true, events:events });

  } catch (err) {
    return jsonResp_({ ok:false, error:String(err && err.message ? err.message : err) });
  }
}

function _handleFixDayAudit_(e) {
  try {
    var name = String((e.parameter && e.parameter.name) || '').trim();
    var date = String((e.parameter && e.parameter.date) || '').trim();
    var limit = Number((e.parameter && e.parameter.limit) || 50);
    if (!isFinite(limit) || limit <= 0) limit = 50;
    if (limit > 200) limit = 200;

    var sh = _fixDayAuditSheet_();
    var lastRow = sh.getLastRow();
    if (lastRow < 2) return jsonResp_({ ok:true, rows:[] });

    var values = sh.getRange(2, 1, lastRow - 1, sh.getLastColumn()).getValues();
    var nameN = name ? _norm(name) : '';

    var out = [];
    for (var i = values.length - 1; i >= 0; i--) {
      var r = values[i];
      var rName = String(r[2] || '');
      var rDate = String(r[3] || '');

      if (nameN && _norm(rName) !== nameN) continue;
      if (date && rDate !== date) continue;

      out.push({
        auditTs: r[0],
        adminEmail: String(r[1] || ''),
        employeeName: String(r[2] || ''),
        date: String(r[3] || ''),
        opType: String(r[4] || ''),
        targetRow: r[5],
        before: String(r[6] || ''),
        after: String(r[7] || ''),
        comment: String(r[8] || '')
      });

      if (out.length >= limit) break;
    }

    return jsonResp_({ ok:true, rows:out });

  } catch (err) {
    return jsonResp_({ ok:false, error:String(err && err.message ? err.message : err) });
  }
}

function _handleFixDayApply_(data) {
  var lock = LockService.getDocumentLock();
  if (!lock.tryLock(10000)) {
    return jsonResp_({ ok:false, error:'Sistem ocupat. Încearcă din nou.' });
  }

  try {
    var name = String((data && data.name) || '').trim();
    var date = String((data && data.date) || '').trim();
    var ops = (data && data.ops) || [];
    var adminEmail = '';

    try {
      adminEmail = String(((data.admin || {}).email) || '').trim();
    } catch(_) {}

    if (!name) return jsonResp_({ ok:false, error:'Missing name' });
    if (!date) return jsonResp_({ ok:false, error:'Missing date' });
    if (!Array.isArray(ops) || ops.length === 0) return jsonResp_({ ok:false, error:'No ops' });

    var sh = _getResponsesSheet_();
    var headers = _getHeaders(sh);
    var cols = _fixDayFindCols_(headers);

    if (!cols.cTs || !cols.cName || !cols.cAction) {
      return jsonResp_({ ok:false, error:'Nu găsesc coloanele: Timestamp / Nume / Acțiune în sheet-ul de răspunsuri.' });
    }

    var applied = 0;
    var results = [];
    var nameN = _norm(name);

    for (var i = 0; i < ops.length; i++) {
      var op = ops[i] || {};
      var type = String(op.type || '').toLowerCase();

      if (type === 'update' || type === 'void') {
        var rowIndex = Number(op.row || 0);
        if (!rowIndex || rowIndex < 2) {
          results.push({ ok:false, type:type, row:op.row, error:'Row invalid' });
          continue;
        }

        // BEFORE snapshot
        var beforeRow = sh.getRange(rowIndex, 1, 1, sh.getLastColumn()).getValues()[0];
        var beforeObj = {
          ts: beforeRow[cols.cTs - 1],
          name: beforeRow[cols.cName - 1],
          action: beforeRow[cols.cAction - 1],
          notes: cols.cNotes ? beforeRow[cols.cNotes - 1] : ''
        };

        // verifică că e chiar angajatul și ziua selectată
        if (_norm(String(beforeObj.name || '')) !== nameN) {
          results.push({ ok:false, type:type, row:rowIndex, error:'Row nu aparține acestui angajat' });
          continue;
        }
        var tsCheck = beforeObj.ts instanceof Date ? beforeObj.ts : new Date(beforeObj.ts);
        if (!(tsCheck instanceof Date) || isNaN(tsCheck.getTime())) {
          results.push({ ok:false, type:type, row:rowIndex, error:'Timestamp invalid pe row' });
          continue;
        }
        var ymd = Utilities.formatDate(tsCheck, TZ_RO, 'yyyy-MM-dd');
        if (ymd !== date) {
          results.push({ ok:false, type:type, row:rowIndex, error:'Row nu aparține zilei selectate' });
          continue;
        }

        // APPLY
        if (type === 'void') {
          sh.getRange(rowIndex, cols.cAction).setValue('VOID');
          if (cols.cNotes) {
            sh.getRange(rowIndex, cols.cNotes).setValue(String(op.notes || 'Admin VOID'));
          }
          _fixDayAppendAudit_(adminEmail, name, date, 'VOID', rowIndex, beforeObj, {
            action:'VOID',
            notes: String(op.notes || 'Admin VOID')
          }, String(op.comment || 'VOID'));

          applied++;
          results.push({ ok:true, type:type, row:rowIndex });

        } else {
          var newTs = new Date(String(op.timestampIso || ''));
          if (isNaN(newTs.getTime())) {
            results.push({ ok:false, type:type, row:rowIndex, error:'timestampIso invalid' });
            continue;
          }

          var newAction = String(op.action || '').trim();
          if (!newAction) {
            results.push({ ok:false, type:type, row:rowIndex, error:'Acțiune goală' });
            continue;
          }

          sh.getRange(rowIndex, cols.cTs).setValue(newTs);
          sh.getRange(rowIndex, cols.cAction).setValue(newAction);

          if (cols.cNotes) {
            sh.getRange(rowIndex, cols.cNotes).setValue(String(op.notes || ''));
          }

          _fixDayAppendAudit_(adminEmail, name, date, 'UPDATE', rowIndex, beforeObj, {
            ts: newTs,
            action: newAction,
            notes: String(op.notes || '')
          }, String(op.comment || 'UPDATE'));

          applied++;
          results.push({ ok:true, type:type, row:rowIndex });
        }

      } else if (type === 'insert') {
        var insTs = new Date(String(op.timestampIso || ''));
        if (isNaN(insTs.getTime())) {
          results.push({ ok:false, type:type, error:'timestampIso invalid' });
          continue;
        }

        // asigură că e aceeași zi
        var insYMD = Utilities.formatDate(insTs, TZ_RO, 'yyyy-MM-dd');
        if (insYMD !== date) {
          results.push({ ok:false, type:type, error:'Insert nu este în ziua selectată' });
          continue;
        }

        var insAction = String(op.action || '').trim();
        if (!insAction) {
          results.push({ ok:false, type:type, error:'Acțiune goală' });
          continue;
        }

        var newRow = sh.getLastRow() + 1;
        sh.insertRowAfter(sh.getLastRow());

        // set minimal: timestamp, name, action, notes
        sh.getRange(newRow, cols.cTs).setValue(insTs);
        sh.getRange(newRow, cols.cName).setValue(name);
        sh.getRange(newRow, cols.cAction).setValue(insAction);

        if (cols.cNotes) {
          sh.getRange(newRow, cols.cNotes).setValue(String(op.notes || ''));
        }

        _fixDayAppendAudit_(adminEmail, name, date, 'INSERT', newRow, {}, {
          ts: insTs,
          name: name,
          action: insAction,
          notes: String(op.notes || '')
        }, String(op.comment || 'INSERT'));

        applied++;
        results.push({ ok:true, type:type, row:newRow });

      } else {
        results.push({ ok:false, type:type, error:'Op type necunoscut' });
      }
    }

    return jsonResp_({ ok:true, applied:applied, results:results });

  } catch (err) {
    return jsonResp_({ ok:false, error:String(err && err.message ? err.message : err) });
  } finally {
    lock.releaseLock();
  }
}

// =====================================================
// FIX DAY (Editor zi) + Audit Log
// Modifică DIRECT "Formular fără titlu (răspunsuri)"
// =====================================================

function _fixDayFindCols_(headers) {
  var cTs = _findCol(headers, ['Marcaj de timp', 'Timestamp', 'Dată', 'Data', 'Time']);
  var cName = _findCol(headers, ['Nume', 'Name', 'Employee']);
  var cAction = _findCol(headers, ['Acțiune', 'Actiune', 'Action']);
  var cNotes = _findCol(headers, ['Notițe', 'Notite', 'Notes', 'Observatii', 'Observații']);
  return { cTs, cName, cAction, cNotes };
}

function _fixDayActionToSheet_(action) {
  var a = String(action || '').trim().toUpperCase();
  var allowed = ['START','PAUSE','UNPAUSE','FINISH','EXTRA_START','EXTRA_FINISH'];
  if (allowed.indexOf(a) >= 0) return a;

  // fallback from your normalization
  var k = _normAction(action);
  if (!k) return 'START';
  k = k.toUpperCase();
  if (k === 'START') return 'START';
  if (k === 'PAUSE') return 'PAUSE';
  if (k === 'UNPAUSE') return 'UNPAUSE';
  if (k === 'FINISH') return 'FINISH';
  if (k === 'EXTRA_START') return 'EXTRA_START';
  if (k === 'EXTRA_FINISH') return 'EXTRA_FINISH';
  return 'START';
}

function _fixDayBuildDate_(dateStr, timeStr) {
  // dateStr: YYYY-MM-DD
  // timeStr: HH:MM or HH:MM:SS
  var ds = String(dateStr || '').trim();
  var ts = String(timeStr || '').trim();

  if (!ds || !ts) return null;
  if (/^\d\d:\d\d$/.test(ts)) ts = ts + ':00';

  var pD = ds.split('-').map(Number);
  var pT = ts.split(':').map(Number);

  if (pD.length !== 3 || pT.length < 2) return null;

  var Y = pD[0], M = pD[1], D = pD[2];
  var h = pT[0] || 0, m = pT[1] || 0, s = pT[2] || 0;

  // Date(Y, M-1, D, h, m, s) => timezone scriptului (Europe/Bucharest)
  return new Date(Y, M - 1, D, h, m, s, 0);
}

function _fixDayReadExisting_(sh, cols, targetName, dateStr) {
  var lr = sh.getLastRow();
  var lc = sh.getLastColumn();
  if (lr < 2) return [];

  var values = sh.getRange(2, 1, lr - 1, lc).getValues();
  var out = [];

  for (var i = 0; i < values.length; i++) {
    var row = values[i];
    var nm = String(row[cols.cName] || '').trim();
    if (nm !== targetName) continue;

    var rawTs = row[cols.cTs];
    if (!rawTs) continue;

    var d = (rawTs instanceof Date) ? rawTs : new Date(rawTs);
    if (isNaN(d.getTime())) continue;

    var dayKey = Utilities.formatDate(d, TZ_RO, 'yyyy-MM-dd');
    if (dayKey !== dateStr) continue;

    out.push({
      row: i + 2,
      dt: d,
      time: Utilities.formatDate(d, TZ_RO, 'HH:mm:ss'),
      action: _fixDayActionToSheet_(row[cols.cAction]),
      notes: cols.cNotes >= 0 ? String(row[cols.cNotes] || '') : '',
      rowValues: row
    });
  }

  out.sort(function (a, b) { return a.dt.getTime() - b.dt.getTime(); });
  return out;
}

function _ensureAuditSheetFixDay_() {
  var ss = SpreadsheetApp.getActive();
  var name = 'AuditLog_FixDay';
  var sh = ss.getSheetByName(name);
  if (!sh) {
    sh = ss.insertSheet(name);
    sh.appendRow([
      'Timestamp',
      'Admin',
      'Employee',
      'Date',
      'Reason',
      'BeforeB64',
      'AfterB64',
      'Change',
      'Mode'
    ]);
  }
  return sh;
}

function _b64ws_(str) {
  return Utilities.base64EncodeWebSafe(Utilities.newBlob(String(str || ''), 'text/plain', 'x').getBytes());
}

function _handleFixDayGet_(e) {
  try {
    var name = String(e.parameter.name || '').trim();
    var dateStr = String(e.parameter.date || '').trim();

    if (!name || !dateStr) {
      return { ok: false, error: 'Missing name/date' };
    }

    var sh = _getResponsesSheet_();
    var headers = sh.getRange(1, 1, 1, sh.getLastColumn()).getValues()[0];
    var cols = _fixDayFindCols_(headers);

    if (cols.cTs < 0 || cols.cName < 0 || cols.cAction < 0) {
      return { ok: false, error: 'Columns not found (timestamp/name/action).' };
    }

    var existing = _fixDayReadExisting_(sh, cols, name, dateStr);

    var events = existing.map(function (ev) {
      return {
        row: ev.row,
        time: ev.time,
        action: ev.action,
        notes: ev.notes || ''
      };
    });

    return { ok: true, data: { events: events } };
  } catch (err) {
    return { ok: false, error: String(err && err.message ? err.message : err) };
  }
}

function _handleFixDayApplyFromPayload_(payloadB64, e) {
  try {
    if (!payloadB64) return { ok: false, error: 'Missing payload' };
    var bytes;
    try{ bytes = Utilities.base64DecodeWebSafe(payloadB64); }
    catch(_e1){ bytes = Utilities.base64Decode(payloadB64); }
    var json = Utilities.newBlob(bytes).getDataAsString('UTF-8');
    var obj = JSON.parse(json);
    return _handleFixDayApply_(obj, e);
  } catch (err) {
    return { ok: false, error: String(err && err.message ? err.message : err) };
  }
}

function _handleFixDayApply_(obj, e) {
  var lock = LockService.getScriptLock();
  lock.waitLock(20000);

  try {
    var admin = String(obj.admin || 'anonymous').trim();
    var name = String(obj.name || '').trim();
    var dateStr = String(obj.date || '').trim();
    var reason = String(obj.reason || 'FixDay').trim();
    var events = Array.isArray(obj.events) ? obj.events : [];

    if (!name || !dateStr) {
      return { ok: false, error: 'Missing name/date' };
    }

    var sh = _getResponsesSheet_();
    var lc = sh.getLastColumn();
    var headers = sh.getRange(1, 1, 1, lc).getValues()[0];
    var cols = _fixDayFindCols_(headers);

    if (cols.cTs < 0 || cols.cName < 0 || cols.cAction < 0) {
      return { ok: false, error: 'Columns not found (timestamp/name/action).' };
    }

    // Read existing (BEFORE)
    var before = _fixDayReadExisting_(sh, cols, name, dateStr);
    var beforeCompact = before.map(function (ev) {
      return { row: ev.row, time: ev.time, action: ev.action, notes: ev.notes || '' };
    });

    // Normalize new list
    var newEvents = [];
    for (var i = 0; i < events.length; i++) {
      var t = String(events[i].time || '').trim();
      var a = _fixDayActionToSheet_(events[i].action);
      var n = String(events[i].notes || '');
      var dt = _fixDayBuildDate_(dateStr, t);
      if (!dt) continue;
      newEvents.push({ dt: dt, time: Utilities.formatDate(dt, TZ_RO, 'HH:mm:ss'), action: a, notes: n });
    }

    // sort by time
    newEvents.sort(function (x, y) { return x.dt.getTime() - y.dt.getTime(); });

    // Template row for append
    var template = null;
    if (before.length) {
      template = before[0].rowValues.slice();
    } else {
      template = new Array(lc).fill('');
    }

    var updated = 0, deleted = 0, appended = 0;

    // UPDATE existing rows 1:1 (by sequence)
    var minLen = Math.min(before.length, newEvents.length);
    for (var k = 0; k < minLen; k++) {
      var rowNo = before[k].row;
      var cur = sh.getRange(rowNo, 1, 1, lc).getValues()[0];

      cur[cols.cTs] = newEvents[k].dt;
      cur[cols.cName] = name;
      cur[cols.cAction] = newEvents[k].action;

      if (cols.cNotes >= 0) cur[cols.cNotes] = newEvents[k].notes || '';

      sh.getRange(rowNo, 1, 1, lc).setValues([cur]);
      updated++;
    }

    // DELETE extra old rows (descending by row index)
    if (before.length > newEvents.length) {
      var toDelete = before.slice(newEvents.length).map(function (x) { return x.row; });
      toDelete.sort(function (a, b) { return b - a; });

      for (var d = 0; d < toDelete.length; d++) {
        sh.deleteRow(toDelete[d]);
        deleted++;
      }
    }

    // APPEND new rows if more events than existing
    if (newEvents.length > before.length) {
      for (var aI = before.length; aI < newEvents.length; aI++) {
        var row = template.slice();

        row[cols.cTs] = newEvents[aI].dt;
        row[cols.cName] = name;
        row[cols.cAction] = newEvents[aI].action;
        if (cols.cNotes >= 0) row[cols.cNotes] = newEvents[aI].notes || '';

        sh.appendRow(row);
        appended++;
      }
    }

    // AFTER compact
    var afterCompact = newEvents.map(function (ev) {
      return { time: ev.time, action: ev.action, notes: ev.notes || '' };
    });

    // AUDIT LOG
    var auditSh = _ensureAuditSheetFixDay_();
    auditSh.appendRow([
      new Date(),
      admin,
      name,
      dateStr,
      reason,
      _b64ws_(JSON.stringify(beforeCompact)),
      _b64ws_(JSON.stringify(afterCompact)),
      (beforeCompact.length + ' → ' + afterCompact.length),
      'rebuild'
    ]);

    SpreadsheetApp.flush();

    return {
      ok: true,
      beforeCount: beforeCompact.length,
      afterCount: afterCompact.length,
      updated: updated,
      deleted: deleted,
      appended: appended,
      auditSheet: 'AuditLog_FixDay'
    };

  } catch (err) {
    return { ok: false, error: String(err && err.message ? err.message : err) };
  } finally {
    try { lock.releaseLock(); } catch (_) {}
  }
}



/*** =========================
 *  FIX DAY V3 (reads/writes full row fields)
 *  Sheet: "Răspunsuri la formular 1" (fallback by name)
 *  Uses Timestamp (ISO) primary; falls back to Marcaj de timp.
 *  JSONP safe: doGet routes through jsonpResp_(e, obj)
 *  ========================= */

function _deaccent_(s){
  return String(s||'')
    .replace(/[ăâ]/g,'a').replace(/[î]/g,'i').replace(/[șş]/g,'s').replace(/[țţ]/g,'t')
    .replace(/[ĂÂ]/g,'a').replace(/[Î]/g,'i').replace(/[ȘŞ]/g,'s').replace(/[ȚŢ]/g,'t');
}

function _hdrKey_(h){
  return _deaccent_(String(h||'').trim().toLowerCase());
}

function _fixColsV3_(headers){
  var idx = {};
  for (var c=0; c<headers.length; c++){
    idx[_hdrKey_(headers[c])] = c;
  }
  function pick(names){
    for (var i=0;i<names.length;i++){
      var k = _hdrKey_(names[i]);
      if (idx.hasOwnProperty(k)) return idx[k];
    }
    return -1;
  }
  return {
    submitted: pick(['Marcaj de timp','Timestamp formular','Marcaj de timp (formular)']),
    name: pick(['Name','Nume','Nume si prenume','Angajat']),
    emailPersonal: pick(['Email personal','Email']),
    action: pick(['Action','Acțiune','Actiune']),
    isoTs: pick(['Timestamp','ISO','Timestamp (ISO)']),
    tip: pick(['Tip de activitate','Activitate','Activity']),
    lat: pick(['Latitude','Lat']),
    lon: pick(['Longitude','Lon','Lng']),
    acc: pick(['Accuracy(m)','Accuracy','Acc']),
    device: pick(['Device','Browser','UserAgent']),
    notes: pick(['Notes','Notite','Observatii','Observații']),
    mapsLink: pick(['MapsLink','Maps Link']),
    locations: pick(['Locations','Locatii','Locații','Location']),
    durataOre: pick(['Durata (ore)','Durata ore','Durata']),
    suplimentarH: pick(['Suplimentar (h)','Suplimentar']),
    extraH: pick(['Extra (h)','Extra']),
    dept: pick(['Departament','Departament ','Departament\u00A0'])
  };
}

function _samePersonV3_(a,b){
  var na = _deaccent_(String(a||'').trim().toLowerCase());
  var nb = _deaccent_(String(b||'').trim().toLowerCase());
  return na && nb && na === nb;
}

function _parseRoDT_(s){
  // dd.MM.yyyy HH:mm:ss
  s = String(s||'').trim();
  var m = s.match(/^(\d{1,2})\.(\d{1,2})\.(\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (!m) return null;
  var dd = parseInt(m[1],10), MM = parseInt(m[2],10)-1, yy = parseInt(m[3],10);
  var hh = parseInt(m[4],10), mi = parseInt(m[5],10), ss = parseInt(m[6]||'0',10);
  var d = new Date(yy,MM,dd,hh,mi,ss);
  if (isNaN(d.getTime())) return null;
  return d;
}

function _toDateV3_(v){
  if (!v) return null;
  if (Object.prototype.toString.call(v)==='[object Date]') return v;
  var d = new Date(v);
  if (!isNaN(d.getTime())) return d;
  var ro = _parseRoDT_(v);
  return ro;
}

function _hmFromDate_(d){
  return Utilities.formatDate(d, TZ_RO, 'HH:mm');
}
function _hmsFromDate_(d){
  return Utilities.formatDate(d, TZ_RO, 'HH:mm:ss');
}

function _dtFromYmdHm_(ymd, hm){
  // ymd: YYYY-MM-DD, hm: HH:mm
  hm = String(hm||'').slice(0,5);
  var parts = ymd.split('-');
  var y = parseInt(parts[0],10), m = parseInt(parts[1],10)-1, da = parseInt(parts[2],10);
  var t = hm.split(':');
  var hh = parseInt(t[0]||'0',10), mi = parseInt(t[1]||'0',10);
  // Create date in script TZ; store ISO (UTC)
  return new Date(y,m,da,hh,mi,0);
}

function fixDayGetDataV3_(e){
  try{
    var p = e && e.parameter ? e.parameter : {};
    var name = String(p.name||'').trim();
    var dateStr = String(p.date||'').trim(); // YYYY-MM-DD
    if (!name) return { ok:false, error:'Lipsește name' };
    if (!dateStr) return { ok:false, error:'Lipsește date (YYYY-MM-DD)' };

    var ss = _pontajSs_();
    var sh = _getResponsesSheet_(ss);
    var lastRow = sh.getLastRow();
    var lastCol = sh.getLastColumn();
    if (lastRow < 2) return { ok:true, events:[], meta:{ name:name, date:dateStr, sheet:sh.getName(), ssTitle:ss.getName() } };

    var headers = sh.getRange(1,1,1,lastCol).getValues()[0];
    var c = _fixColsV3_(headers);

    if (c.name < 0 || c.action < 0 || (c.isoTs < 0 && c.submitted < 0)){
      return { ok:false, error:'Nu am găsit coloanele obligatorii (Name, Action, Timestamp sau Marcaj de timp).' };
    }

    var rng = sh.getRange(2,1,lastRow-1,lastCol);
    var values = rng.getValues();
    var disp = rng.getDisplayValues();

    var events = [];
    var meta = { name:name, date:dateStr, sheet: sh.getName(), ssTitle: ss.getName() };
    var first = true;

    for (var i=0; i<values.length; i++){
      var row = values[i];
      var drow = disp[i];

      if (!_samePersonV3_(row[c.name], name)) continue;

      // determine timestamp (prefer ISO column, fallback to "Marcaj de timp")
      var dt = null;
      if (c.isoTs >= 0) dt = _toDateV3_(row[c.isoTs]);
      if (!dt && c.submitted >= 0) dt = _toDateV3_(row[c.submitted]);
      if (!dt) continue;

      var ymd = Utilities.formatDate(dt, TZ_RO, 'yyyy-MM-dd');
      if (ymd !== dateStr) continue;

      if (first){
        if (c.emailPersonal >= 0) meta.email = String(drow[c.emailPersonal]||'').trim();
        if (c.dept >= 0) meta.dept = String(drow[c.dept]||'').trim();
        first = false;
      }

      // Use DISPLAY values for everything shown/edited (so you see EXACTLY what's in sheet)
      var fields = {
        submitted: (c.submitted>=0 ? drow[c.submitted] : ''),
        name: (c.name>=0 ? drow[c.name] : ''),
        emailPersonal: (c.emailPersonal>=0 ? drow[c.emailPersonal] : ''),
        action: (c.action>=0 ? drow[c.action] : ''),
        timestamp: (c.isoTs>=0 ? drow[c.isoTs] : ''),
        tip: (c.tip>=0 ? drow[c.tip] : ''),
        latitude: (c.lat>=0 ? drow[c.lat] : ''),
        longitude: (c.lon>=0 ? drow[c.lon] : ''),
        accuracy: (c.acc>=0 ? drow[c.acc] : ''),
        device: (c.device>=0 ? drow[c.device] : ''),
        notes: (c.notes>=0 ? drow[c.notes] : ''),
        mapsLink: (c.mapsLink>=0 ? drow[c.mapsLink] : ''),
        locations: (c.locations>=0 ? drow[c.locations] : ''),
        durataOre: (c.durataOre>=0 ? drow[c.durataOre] : ''),
        suplimentarH: (c.suplimentarH>=0 ? drow[c.suplimentarH] : ''),
        extraH: (c.extraH>=0 ? drow[c.extraH] : ''),
        dept: (c.dept>=0 ? drow[c.dept] : '')
      };

      var rawAction = (c.action>=0 ? (drow[c.action] || row[c.action]) : '');
      events.push({
        row: i+2,
        // UI time fields
        localTime: _hmFromDate_(dt),
        localTimeSec: _hmsFromDate_(dt),
        iso: dt.toISOString(),
        // normalized
        action: String(rawAction||'').toUpperCase(),
        rawAction: String(rawAction == null ? '' : rawAction),

        // flattened extras (frontend expects these keys directly)
        formTs: fields.submitted,
        name: fields.name || String(row[c.name]||''),
        emailPersonal: fields.emailPersonal,
        isoTs: (c.isoTs>=0 ? String(row[c.isoTs]||'') : ''),
        tip: fields.tip,
        lat: fields.latitude,
        lon: fields.longitude,
        acc: fields.accuracy,
        device: fields.device,
        notes: fields.notes,
        mapsLink: fields.mapsLink,
        locations: fields.locations,
        durataOre: fields.durataOre,
        suplimentarH: fields.suplimentarH,
        extraH: fields.extraH,
        dept: fields.dept,

        fields: fields
      });
    }

    // stable sort
    events.sort(function(a,b){
      if (a.iso < b.iso) return -1;
      if (a.iso > b.iso) return 1;
      return (a.row||0) - (b.row||0);
    });

    return { ok:true, events: events, meta: meta };
  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }
}




function fixDayApplyFromPayloadV3_(e){
  try{
    var p = e && e.parameter ? e.parameter : {};
    var payloadB64 = String(p.payload||'').trim();
    if (!payloadB64) return { ok:false, error:'Missing payload' };

    // guard by ADMIN_KEY if configured
    var requiredKey = PropertiesService.getScriptProperties().getProperty('ADMIN_KEY');
    if (requiredKey){
      var keyQ = String(p.key||'').trim();
      // key can also be inside payload JSON
      if (!keyQ) {
        // decode enough to find key (safe)
        try{
          var bytesT;
          try{ bytesT = Utilities.base64DecodeWebSafe(payloadB64); }
          catch(_e2){ bytesT = Utilities.base64Decode(payloadB64); }
          var jsonT = Utilities.newBlob(bytesT).getDataAsString('UTF-8');
          var objT = JSON.parse(jsonT);
          keyQ = String(objT.adminKey || objT.key || '').trim();
        }catch(_){}
      }
      if (!keyQ || keyQ !== requiredKey){
        return { ok:false, error:'ADMIN_KEY invalid' };
      }
    }

    var bytes;
    try{ bytes = Utilities.base64DecodeWebSafe(payloadB64); }
    catch(_e1){ bytes = Utilities.base64Decode(payloadB64); }
    var json = Utilities.newBlob(bytes).getDataAsString('UTF-8');
    var obj = JSON.parse(json);

    return fixDayApplyDataV3_(obj);
  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }
}

function _setIfPresent_(row, colIndex, value, hasKey){
  if (colIndex < 0) return;
  if (!hasKey) return;
  row[colIndex] = (value == null) ? '' : value;
}

function fixDayApplyDataV3_(obj){
  var lock = LockService.getScriptLock();
  lock.waitLock(20000);
  try{
    obj = obj || {};
    var name = String(obj.name||obj.employee||'').trim();
    var dateStr = String(obj.date||'').trim();
    var events = Array.isArray(obj.events) ? obj.events : [];
    if (!name) return { ok:false, error:'Lipsește name' };
    if (!dateStr) return { ok:false, error:'Lipsește date (YYYY-MM-DD)' };

    var ss = _pontajSs_();
    var sh = _getResponsesSheet_(ss);
    var lastCol = sh.getLastColumn();
    var headers = sh.getRange(1,1,1,lastCol).getValues()[0];
    var c = _fixColsV3_(headers);

    if (c.name < 0 || c.action < 0 || (c.isoTs < 0 && c.submitted < 0)){
      return { ok:false, error:'Nu am găsit coloanele obligatorii (Name, Action, Timestamp sau Marcaj de timp).' };
    }

    // Load all rows to find existing in day
    var lastRow = sh.getLastRow();
    var values = (lastRow >= 2) ? sh.getRange(2,1,lastRow-1,lastCol).getValues() : [];
    var existingRows = [];
    for (var i=0;i<values.length;i++){
      var row = values[i];
      if (!_samePersonV3_(row[c.name], name)) continue;

      var dt = null;
      if (c.isoTs >= 0) dt = _toDateV3_(row[c.isoTs]);
      if (!dt && c.submitted >= 0) dt = _toDateV3_(row[c.submitted]);
      if (!dt) continue;

      var ymd = Utilities.formatDate(dt, TZ_RO, 'yyyy-MM-dd');
      if (ymd !== dateStr) continue;
      existingRows.push(i+2);
    }
    existingRows.sort(function(a,b){ return a-b; });

    // Normalize incoming events.
    // IMPORTANT: we recompute ISO + "Marcaj de timp" from selected HH:mm so sheet stays consistent.
    var norm = events.map(function(ev){
      ev = ev || {};
      var hm = String(ev.time || ev.localTime || '').trim().slice(0,5);
      if (!hm) hm = '00:00';
      var dt = _dtFromYmdHm_(dateStr, hm);
      var act = String(ev.action || ev.rawAction || '').trim();
      act = act ? act.toUpperCase() : 'START';
      var actSheet = act.toLowerCase();

      var fields = ev.fields || ev;

      return {
        hm: hm,
        dt: dt,
        iso: dt.toISOString(),
        marcaj: Utilities.formatDate(dt, TZ_RO, 'dd.MM.yyyy HH:mm:ss'),
        action: act,
        actionSheet: actSheet,
        fields: fields
      };
    }).filter(function(x){ return !!x; });

    norm.sort(function(a,b){ return a.iso < b.iso ? -1 : (a.iso > b.iso ? 1 : 0); });

    // If user wants to clear all events, allow it (delete existing)
    if (!norm.length){
      for (var d=existingRows.length-1; d>=0; d--){
        sh.deleteRow(existingRows[d]);
      }
      SpreadsheetApp.flush();
      return { ok:true, sheet: sh.getName(), updated:0, appended:0, deleted: existingRows.length, cleared:true };
    }

    var used = Math.min(existingRows.length, norm.length);

    function buildRow(baseRow, ev){
      var row = baseRow ? baseRow.slice() : new Array(lastCol).fill('');
      var f = ev.fields || {};
      var has = function(k){ return f && Object.prototype.hasOwnProperty.call(f, k); };

      // 1) Marcaj de timp (submitted) — ALWAYS from dt (so it matches Timestamp)
      if (c.submitted >= 0){
        row[c.submitted] = ev.dt;
      }

      // 2) Name / Email
      if (c.name >= 0) row[c.name] = name;
      if (c.emailPersonal >= 0){
        // keep existing if not provided
        if (has('emailPersonal')) row[c.emailPersonal] = f.emailPersonal;
        else if (has('email')) row[c.emailPersonal] = f.email;
      }

      // 3) Action + Timestamp ISO (ALWAYS from dt)
      if (c.action >= 0) row[c.action] = ev.actionSheet;
      if (c.isoTs >= 0) row[c.isoTs] = ev.iso;

      // 4) Extra fields (skip Indicator/Telegram by request)
      _setIfPresent_(row, c.tip, has('tip') ? f.tip : (has('activity')?f.activity:''), has('tip')||has('activity'));
      _setIfPresent_(row, c.lat, has('latitude') ? f.latitude : (has('lat')?f.lat:''), has('latitude')||has('lat'));
      _setIfPresent_(row, c.lon, has('longitude') ? f.longitude : (has('lon')?f.lon: (has('lng')?f.lng:'')), has('longitude')||has('lon')||has('lng'));
      _setIfPresent_(row, c.acc, has('accuracy') ? f.accuracy : (has('acc')?f.acc:''), has('accuracy')||has('acc'));
      _setIfPresent_(row, c.device, f.device, has('device'));
      _setIfPresent_(row, c.notes, f.notes, has('notes'));
      _setIfPresent_(row, c.mapsLink, has('mapsLink') ? f.mapsLink : (has('maps')?f.maps:''), has('mapsLink')||has('maps'));
      _setIfPresent_(row, c.locations, f.locations, has('locations'));
      // durataOre will be recomputed automatically after apply (see fixDayRecomputeDurationsV3_)
      _setIfPresent_(row, c.suplimentarH, f.suplimentarH, has('suplimentarH'));
      _setIfPresent_(row, c.extraH, f.extraH, has('extraH'));
      _setIfPresent_(row, c.dept, has('dept') ? f.dept : (has('departament')?f.departament:(obj.dept||'')), has('dept')||has('departament')||!!obj.dept);

      return row;
    }

    // Update existing rows
    for (var k=0; k<used; k++){
      var rIndex = existingRows[k];
      var base = sh.getRange(rIndex,1,1,lastCol).getValues()[0];
      var newRow = buildRow(base, norm[k]);
      sh.getRange(rIndex,1,1,lastCol).setValues([newRow]);
    }

    // Append new rows
    for (var a=used; a<norm.length; a++){
      var newRow2 = buildRow(null, norm[a]);
      sh.appendRow(newRow2);
    }

    // Delete extra existing rows
    for (var dd=existingRows.length-1; dd>=norm.length; dd--){
      sh.deleteRow(existingRows[dd]);
    }

    SpreadsheetApp.flush();

    // Recompute duration automatically (START..FINISH minus PAUSE segments)
    try{
      fixDayRecomputeDurationsV3_(sh, c, name, dateStr);
    }catch(_eDur){}

    return {
      ok:true,
      sheet: sh.getName(),
      updated: used,
      appended: Math.max(0, norm.length-used),
      deleted: Math.max(0, existingRows.length-norm.length),
      recompute: true
    };

  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }finally{
    try{ lock.releaseLock(); }catch(_){}
  }
}



/**
 * Recompute Durata (ore) for a day based on events:
 * work = (FINISH - START) - pauseTotal, where pauseTotal sums PAUSE..UNPAUSE pairs.
 * Writes result to the FINISH row(s) in "Durata (ore)" column (if present).
 * Also recomputes Extra (h) for EXTRA_FINISH based on EXTRA_START..EXTRA_FINISH (if present).
 */
function fixDayRecomputeDurationsV3_(sh, c, name, dateStr){
  if (!sh || !c) return;
  if (c.durataOre < 0 && c.extraH < 0) return;

  var lastRow = sh.getLastRow();
  var lastCol = sh.getLastColumn();
  if (lastRow < 2) return;

  var vals = sh.getRange(2,1,lastRow-1,lastCol).getValues();
  var rows = [];

  for (var i=0;i<vals.length;i++){
    var row = vals[i];
    if (c.name < 0 || !_samePersonV3_(row[c.name], name)) continue;

    var dt = null;
    if (c.isoTs >= 0) dt = _toDateV3_(row[c.isoTs]);
    if (!dt && c.submitted >= 0) dt = _toDateV3_(row[c.submitted]);
    if (!dt) continue;

    var ymd = Utilities.formatDate(dt, TZ_RO, 'yyyy-MM-dd');
    if (ymd !== dateStr) continue;

    var act = String((c.action>=0 ? row[c.action] : '') || '').trim();
    var actUp = act.toUpperCase();
    rows.push({ r:i+2, dt:dt, act:actUp });
  }

  if (!rows.length) return;

  rows.sort(function(a,b){ return a.dt.getTime() - b.dt.getTime(); });

  var start = null, finish = null;
  var extraStart = null, extraFinish = null;

  var pauseOpen = null;
  var pauseMs = 0;

  // helper: treat both lower/upper
  function isAct(o, x){
    x = String(x).toUpperCase();
    return o.act === x || o.act === x.toLowerCase();
  }

  for (var j=0;j<rows.length;j++){
    var o = rows[j];
    var a = o.act;

    if (a === 'START' || a === 'start') start = start==null ? o.dt : (o.dt < start ? o.dt : start);
    if (a === 'FINISH' || a === 'finish') finish = finish==null ? o.dt : (o.dt > finish ? o.dt : finish);

    if (a === 'EXTRA_START' || a === 'extra_start') extraStart = extraStart==null ? o.dt : (o.dt < extraStart ? o.dt : extraStart);
    if (a === 'EXTRA_FINISH' || a === 'extra_finish') extraFinish = extraFinish==null ? o.dt : (o.dt > extraFinish ? o.dt : extraFinish);

    if (a === 'PAUSE' || a === 'pause'){
      pauseOpen = o.dt;
    }
    if ((a === 'UNPAUSE' || a === 'unpause') && pauseOpen){
      var dms = o.dt.getTime() - pauseOpen.getTime();
      if (dms > 0) pauseMs += dms;
      pauseOpen = null;
    }
  }

  var workHours = null;
  if (start && finish && finish.getTime() > start.getTime()){
    workHours = (finish.getTime() - start.getTime() - pauseMs) / 3600000;
    if (workHours < 0) workHours = 0;
  }

  var extraHours = null;
  if (extraStart && extraFinish && extraFinish.getTime() > extraStart.getTime()){
    extraHours = (extraFinish.getTime() - extraStart.getTime()) / 3600000;
    if (extraHours < 0) extraHours = 0;
  }

  
  // write duration to FINISH rows (or clear if cannot compute)
  if (c.durataOre >= 0){
    for (var k=0;k<rows.length;k++){
      if (rows[k].act === 'FINISH' || rows[k].act === 'finish'){
        if (workHours != null) sh.getRange(rows[k].r, c.durataOre+1).setValue(workHours);
        else sh.getRange(rows[k].r, c.durataOre+1).setValue('');
      }
    }
  }

  // write extraH to EXTRA_FINISH rows (or clear if cannot compute)
  if (c.extraH >= 0){
    for (var kk=0;kk<rows.length;kk++){
      if (rows[kk].act === 'EXTRA_FINISH' || rows[kk].act === 'extra_finish'){
        if (extraHours != null) sh.getRange(rows[kk].r, c.extraH+1).setValue(extraHours);
        else sh.getRange(rows[kk].r, c.extraH+1).setValue('');
      }
    }
  }

  SpreadsheetApp.flush();
}





/************* FIX DAY CHUNKED SAVE (JSONP) - V3 *************
 * Scop: permite salvări cu payload mare (URL > ~7KB) din GitHub Pages.
 * Frontend: trimite bucăți (part) în CacheService, apoi finalizează.
 * Parametri:
 *  - sid: session id
 *  - i: index chunk (0..n-1)
 *  - n: total chunks
 *  - part: substring din payloadB64 (websafe)
 *  - key: ADMIN_KEY (opțional, dacă e setat în Script Properties)
 *************************************************************/

function _fixDayRequireAdminKey_(p){
  var requiredKey = PropertiesService.getScriptProperties().getProperty('ADMIN_KEY');
  if (!requiredKey) return { ok:true };
  var keyQ = String((p && (p.key || p.k)) || '').trim();
  if (!keyQ) return { ok:false, error:'ADMIN_KEY missing' };
  if (keyQ !== requiredKey) return { ok:false, error:'ADMIN_KEY invalid' };
  return { ok:true };
}

function fixDayApplyChunkV3_(e){
  try{
    var p = e && e.parameter ? e.parameter : {};
    var guard = _fixDayRequireAdminKey_(p);
    if (!guard.ok) return guard;

    var sid = String(p.sid||'').trim();
    var part = String(p.part||'');
    var i = parseInt(p.i||'0',10);
    var n = parseInt(p.n||'0',10);
    if (!sid) return { ok:false, error:'Missing sid' };
    if (!part) return { ok:false, error:'Missing part' };
    if (!isFinite(i) || i<0) return { ok:false, error:'Invalid i' };
    if (!isFinite(n) || n<=0) return { ok:false, error:'Invalid n' };

    var cache = CacheService.getScriptCache();
    cache.put('fd:'+sid+':n', String(n), 600);
    cache.put('fd:'+sid+':'+i, part, 600);

    return { ok:true, sid:sid, i:i, n:n, len: part.length };
  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }
}

function fixDayApplyFinalizeV3_(e){
  try{
    var p = e && e.parameter ? e.parameter : {};
    var guard = _fixDayRequireAdminKey_(p);
    if (!guard.ok) return guard;

    var sid = String(p.sid||'').trim();
    if (!sid) return { ok:false, error:'Missing sid' };

    var cache = CacheService.getScriptCache();
    var n = parseInt(p.n || cache.get('fd:'+sid+':n') || '0', 10);
    if (!isFinite(n) || n<=0) return { ok:false, error:'Missing/invalid n' };

    var parts = [];
    for (var i=0; i<n; i++){
      var v = cache.get('fd:'+sid+':'+i);
      if (v == null) return { ok:false, error:'Missing chunk '+i+'/'+n };
      parts.push(v);
    }

    // cleanup first (avoid leaving junk even if parsing fails)
    for (var j=0; j<n; j++){
      cache.remove('fd:'+sid+':'+j);
    }
    cache.remove('fd:'+sid+':n');

    var payloadB64 = parts.join('');

    // decode + apply
    var bytes;
    try{ bytes = Utilities.base64DecodeWebSafe(payloadB64); }
    catch(_e1){ bytes = Utilities.base64Decode(payloadB64); }
    var json = Utilities.newBlob(bytes).getDataAsString('UTF-8');
    var obj = JSON.parse(json);

    // key can also be inside payload (but we already checked query key)
    return fixDayApplyDataV3_(obj);
  }catch(err){
    return { ok:false, error:String(err && err.message ? err.message : err) };
  }
}

/*** ====== /FIX DAY CHUNKED SAVE (V3) ====== ***/

/*** ====== END FIX DAY V3 ====== ***/
